---
title: "Project Topic 3 Team 4"
author: "Khalida Dushimova, Madleen Piegsa, Greata Karathanos und Richard Langi Efraim"
date: "4/27/2022"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```


```{r}
library(tidyverse)
library(heatmaply)
library(scales)
library(gganimate)
library(dplyr) ##for the select function 
library(tibble)
library(ggiraph)
library(ggiraphExtra)
library(ggplot2)
library(qqplotr)
```

## 1. Description of dataset (Raw data)



```{r 1.1 loading data}
#loading "RDeeP_A549_NS.csv" into Data.raw dataframe
#MS_Table <- read.table("~/Desktop/2022-topic-03-team-04/RDeeP_A549_NS.csv", header=TRUE, row.names=1, sep = ";")
Data.raw <- read.table("~/Desktop/2022-topic-03-team-04/RDeeP_A549_NS.csv", header=TRUE, row.names=1, sep = ";")
#creating a copy of Data.raw and saving it as Data.copy
Data.copy = Data.raw

```


```{r}
head(Data.copy)
dim(Data.copy)
# the dataset has 150 columns and 3680 rows
# restruction needed 
# we want to restructure the dataset by fractions and divide it in two datasets, one for RNAse and one for Ctrl
# we need to write a function that restructures the dataset
## Therefor we pick by repetitions and create Rep1, Rep2 and Rep3 vectors:starting with 1(Ctrl) or with 2(RNase) 
## every six columns there is a new fraction 
```



```{r 1.2 Raw data reorganization}
restructure_func = function(input_df,start){ #start = 1 for Ctrl and start = 2 for RNase.
  Vector.Rep1 <- c(seq(from =start, to = 150, by = 6)) # by 6 to reach the next fraction 
  Vector.Rep2 <- c(seq(from =start+2, to = 150, by = 6))
  Vector.Rep3 <- c(seq(from =start+4, to = 150, by = 6))
  output_df = as.data.frame(matrix(nrow = 3*3680, ncol=25)) 
  
  
  #Naming the fractions 
  for (i in 1:25) {
    s = paste("Fraction",i,sep="_")
   colnames(output_df)[i] = s
  }
  
  
  #Assignment of values and row names
  
  k = 1 #Row number of the old dataframe
  i = 1 #Row number of the new dataframe
  while (i <= dim(output_df)[1]) { # All Rows of the new dataframes will be selected
    output_df[i,] = input_df[k,Vector.Rep1] #The values of Rep 1 are assigned to the row
    row.names(output_df)[i] = paste(rownames(input_df)[k],"Rep",1,sep="_") #The row is given a name of Protein_Rep_1
    i = i + 1
    
    output_df[i,] = input_df[k,Vector.Rep2] # Repeat for Rep 2
    row.names(output_df)[i] = paste(rownames(input_df)[k],"Rep",2,sep="_")
    i = i + 1
    
    output_df[i,] = input_df[k,Vector.Rep3] # Repeat for Rep 3
    row.names(output_df)[i] = paste(rownames(input_df)[k],"Rep",3,sep="_")
    i = i + 1
    
    k = k + 1 # The row of the old dataframe is advanced by 1
  }
  return(output_df)
}
Ctrl = restructure_func(Data.copy,1)
RNase = restructure_func(Data.copy,2)
```



```{r}
Ctrl = t(Ctrl)
Ctrl = data.frame(Ctrl) ## In order to be able to use the select function

RNase = t(RNase)
RNase = data.frame(RNase)

```








```{r Plots for SPB6_Human_Protein}
Fractions = c(1:25)
SPB6_Human_Protein_Ctrl = ggplot() + 
  geom_line(data = select(Ctrl,1),  aes(x = Fractions, y = SPB6_HUMAN_Rep_1, color= 'Ctrl_Rep1')) + 
  
  geom_line(data = select(Ctrl,2),  aes(x = Fractions, y = SPB6_HUMAN_Rep_2 , color= 'Ctrl_Rep2')) + 
  
  geom_line(data = select(Ctrl,3),  aes(x = Fractions, y = SPB6_HUMAN_Rep_3 , color= 'Ctrl_Rep3')) +
  
  scale_colour_manual(name="legend",values=c(Ctrl_Rep1="blue2",Ctrl_Rep2="cyan3", Ctrl_Rep3="violetred4")) +
  
  labs(title="SPB6_HUMAN_Ctrl", y= "Protein Amount") 
 SPB6_Human_Protein_Ctrl + scale_x_continuous(breaks = seq(1, 25, by = 1))
  
  
SPB6_Human_Protein_RNase = ggplot() + 
  geom_line(data = select(RNase,1),  aes(x = Fractions, y = SPB6_HUMAN_Rep_1 , color= 'RNase_Rep1')) + 
  
  geom_line(data = select(RNase,2), aes(x = Fractions, y = SPB6_HUMAN_Rep_2, color= 'RNase_Rep2')) +
  
  geom_line(data = select(RNase,3), aes(x = Fractions, y = SPB6_HUMAN_Rep_3, color= 'RNase_Rep3')) +
  
   scale_colour_manual(name="legend",values=c(RNase_Rep1="blue2",RNase_Rep2="cyan3", RNase_Rep3= "violetred4")) +
  
  labs(title="SPB6_HUMAN_RNase", y= "Protein Amount") 
  SPB6_Human_Protein_RNase + scale_x_continuous(breaks = seq(1, 25, by = 1))
  
 
  
SPB6_Human_Protein = ggplot() +
 geom_line(data = select(Ctrl,1),  aes(x = Fractions, y = SPB6_HUMAN_Rep_1, color= 'Ctrl_Rep1')) + 
  
  geom_line(data = select(Ctrl,2),  aes(x = Fractions, y = SPB6_HUMAN_Rep_2 , color= 'Ctrl_Rep2')) + 
  
  geom_line(data = select(Ctrl,3),  aes(x = Fractions, y = SPB6_HUMAN_Rep_3 , color= 'Ctrl_Rep3')) +
  
  geom_line(data = select(RNase,1),  aes(x = Fractions, y = SPB6_HUMAN_Rep_1 , color= 'RNase_Rep1')) + 
  
  geom_line(data = select(RNase,2), aes(x = Fractions, y = SPB6_HUMAN_Rep_2, color= 'RNase_Rep2')) +
  
  geom_line(data = select(RNase,3), aes(x = Fractions, y = SPB6_HUMAN_Rep_3 , color= 'RNase_Rep3')) +
  
  scale_colour_manual(name="legend",values=c(Ctrl_Rep1="blue2",RNase_Rep1="cyan3", Ctrl_Rep2="violetred4", RNase_Rep2="tomato1",Ctrl_Rep3="darkviolet", RNase_Rep3="pink")) +
  
  labs(title="SPB6_HUMAN", y= "Protein Amount") 
  SPB6_Human_Protein + scale_x_continuous(breaks = seq(1, 25, by = 1))
 
# RNA associates with proteins to form RNA-Protein complexes that play key regulatory roles in cellular processes --> RNA metabolism and the regulation of gene expression 
# concept of RNA dependence (R-DeeP) describes proteins and protein complexes whose interactions are directly or indirectly dependent on the presence of RNA 
# aim: identify RNA-dependent proteins from the position of the proteins in an untreated cell lysate as t
```


```{r}
Fractions = c(1:25)
MICA_HUMAN_Protein  = ggplot() +
 geom_line(data = select(Ctrl, contains("MICA_HUMAN_Rep_1")),  aes(x = Fractions, y = MICA_HUMAN_Rep_1, color= 'Ctrl_Rep1')) + 
  
  geom_line(data = select(Ctrl, contains("MICA_HUMAN_Rep_2")),  aes(x = Fractions, y = MICA_HUMAN_Rep_2, color= 'Ctrl_Rep2')) + 
  
  geom_line(data = select(Ctrl, contains("MICA_HUMAN_Rep_3")),  aes(x = Fractions, y = MICA_HUMAN_Rep_3 , color= 'Ctrl_Rep3')) +
  
  geom_line(data = select(RNase, contains("MICA_HUMAN_Rep_1")),  aes(x = Fractions, y = MICA_HUMAN_Rep_1 , color= 'RNase_Rep1')) + 
  
  geom_line(data = select(RNase, contains("MICA_HUMAN_Rep_2")), aes(x = Fractions, y = MICA_HUMAN_Rep_2, color= 'RNase_Rep2')) +
  
  geom_line(data = select(RNase, contains("MICA_HUMAN_Rep_3")), aes(x = Fractions, y = MICA_HUMAN_Rep_3 , color= 'RNase_Rep3')) +
  
  scale_colour_manual(name="legend",values=c(Ctrl_Rep1="blue2",RNase_Rep1="green4", Ctrl_Rep2="magenta1", RNase_Rep2="tomato1",Ctrl_Rep3="darkviolet", RNase_Rep3="turquoise4")) +
  
  labs(title="MICA_HUMAN_Protein", y= "Protein Amount") 
  MICA_HUMAN_Protein + scale_x_continuous(breaks = seq(1, 25, by = 1))
  
MICA_HUMAN_Protein_Ctrl = ggplot() + 
  geom_line(data = select(Ctrl, contains("MICA_HUMAN_Rep_1")),  aes(x = Fractions, y = MICA_HUMAN_Rep_1, color= 'Ctrl_Rep1')) + 
  
  geom_line(data = select(Ctrl, contains("MICA_HUMAN_Rep_2")),  aes(x = Fractions, y = MICA_HUMAN_Rep_2 , color= 'Ctrl_Rep2')) + 
  
  geom_line(data = select(Ctrl, contains("MICA_HUMAN_Rep_3")),  aes(x = Fractions, y = MICA_HUMAN_Rep_3 , color= 'Ctrl_Rep3')) +
  
  scale_colour_manual(name="legend",values=c(Ctrl_Rep1="blue2",Ctrl_Rep2="purple4", Ctrl_Rep3="magenta1")) +
  
  labs(title="MICA_HUMAN_Ctrl", y= "Protein Amount") 
 MICA_HUMAN_Protein_Ctrl + scale_x_continuous(breaks = seq(1, 25, by = 1))
  
  
MICA_Human_Protein_RNase = ggplot() + 
  geom_line(data = select(RNase, contains("MICA_HUMAN_Rep_1")),  aes(x = Fractions, y = MICA_HUMAN_Rep_1 , color= 'RNase_Rep1')) + 
  
  geom_line(data = select(RNase,contains("MICA_HUMAN_Rep_2")), aes(x = Fractions, y = MICA_HUMAN_Rep_2, color= 'RNase_Rep2')) +
  
  geom_line(data = select(RNase,contains("MICA_HUMAN_Rep_3")), aes(x = Fractions, y = MICA_HUMAN_Rep_3, color= 'RNase_Rep3')) +
  
   scale_colour_manual(name="legend",values=c(RNase_Rep1="blue2",RNase_Rep2="green4", RNase_Rep3= "magenta1")) +
  
  labs(title="MICA_HUMAN_RNase", y= "Protein Amount") 
  MICA_Human_Protein_RNase + scale_x_continuous(breaks = seq(1, 25, by = 1))  
```







## 1. Evaluation of the reproducibility of the experiments 

To investigate the protein amount of the replicates further we sum up the total protein amount of all genes per sample replicate and plot them side by side in a bar plot. We can see that there is a huge difference between the RNase samples and also the Ctrl samples do not align.

In conclusion the protein amounts differ and are not well comparable. 

Possible causes for this fluctuation of the protein amounts lay in the experimental design of the data generation. The sucrose gradients were all produced in one step to minimize the variations. But had to be transported to the ultracentrifugation and were then fractioned by hand. And as we see the lysates can differ in their containing protein amount.




```{r}
Rep_1_Ctrl <- Ctrl %>% select(contains("Rep_1"))
Rep_1_Ctrl_sums = colSums(Rep_1_Ctrl) 
Rep_2_Ctrl <- Ctrl %>% select(contains("Rep_2"))
Rep_2_Ctrl_sums = colSums(Rep_2_Ctrl) 
Rep_3_Ctrl <- Ctrl %>% select(contains("Rep_3"))
Rep_3_Ctrl_sums = colSums(Rep_3_Ctrl) 

Rep_1_RNase <- RNase %>% select(contains("Rep_1"))
Rep_1_RNase_sums = colSums(Rep_1_RNase)
Rep_2_RNase <- RNase %>% select(contains("Rep_2"))
Rep_2_RNase_sums = colSums(Rep_2_RNase)
Rep_3_RNase <- RNase %>% select(contains("Rep_3"))
Rep_3_RNase_sums = colSums(Rep_3_RNase)

Ctrl_sums = cbind(Rep_1_Ctrl_sums, Rep_2_Ctrl_sums, Rep_3_Ctrl_sums)
RNase_sums = cbind(Rep_1_RNase_sums, Rep_2_RNase_sums, Rep_3_RNase_sums)

Ctrl_RNase_sums = cbind(Ctrl_sums, RNase_sums)

Total_Protein_amount = colSums(Ctrl_RNase_sums)
Total_Protein_amount

value = Total_Protein_amount
plotdata = data.frame(value, names=c("Ctrl1", "Ctrl2", "Ctrl3", "RNase1", "RNase2", "RNase3"))
ggplot(data = plotdata, aes(x = names, y = value)) + geom_bar(stat = "identity")                      
                          
```










## 2. Normalization (Fractionwise)



```{r}
Rep_1_Ctrl_f = t(Rep_1_Ctrl)
Rep_1_Ctrl_fsums = colSums(Rep_1_Ctrl_f)


Rep_2_Ctrl_f = t(Rep_2_Ctrl)
Rep_2_Ctrl_fsums = colSums(Rep_2_Ctrl_f)


Rep_3_Ctrl_f = t(Rep_3_Ctrl)
Rep_3_Ctrl_fsums = colSums(Rep_3_Ctrl_f)


Rep_1_RNase_f = t(Rep_1_RNase)
Rep_1_RNase_fsums =colSums(Rep_1_RNase_f)

Rep_2_RNase_f = t(Rep_2_RNase)
Rep_2_RNase_fsums = colSums(Rep_2_RNase_f)

Rep_3_RNase_f = t(Rep_3_RNase)
Rep_3_RNase_fsums = colSums(Rep_3_RNase_f)

Total_Protein_by_fractions = cbind(Rep_1_Ctrl_fsums,Rep_2_Ctrl_fsums, Rep_3_Ctrl_fsums, Rep_1_RNase_fsums, Rep_2_RNase_fsums, Rep_3_RNase_fsums)


Total_Protein_norm = t(Total_Protein_by_fractions)/Total_Protein_amount
Total_Protein_norm = as.data.frame(Total_Protein_norm)
Total_Protein_norm

Total_Protein_amount_norm = rowSums(Total_Protein_norm)


Total_Protein_amount_norm
plotdata_norm = data.frame(Total_Protein_amount_norm, Replicates = c("Ctrl1", "Ctrl2", "Ctrl3", "RNase1", "RNase2", "RNase3"))
ggplot(data = plotdata_norm, aes(x = Replicates, y = Total_Protein_amount_norm)) + geom_bar(stat = "identity")                      
                          
```
```{r}
## same concept but in general function 
norm_func = function(x) { 
  x/sum(x) 
}
# Applying the normalization to the data
RNase_Data_norm = data.frame(apply(RNase, 1, norm_func))


Ctrl_Data_norm = data.frame(apply(Ctrl, 1, norm_func))


#Remove the NAs that result from some proteins having 0 Protein amount in certain repetitions.
Ctrl_Data_norm[is.na(Ctrl_Data_norm)] <- 0
Ctrl_Data_norm
tCtrl_Norm <- as.data.frame(t(Ctrl_Data_norm))
tCtrl_Norm

RNase_Data_norm[is.na(RNase_Data_norm)] <- 0
RNase_Data_norm

tRNase_Norm <- as.data.frame(t(RNase_Data_norm))
tRNase_Norm
```
```{r}
#Normalized 
Rep_1_Ctrl_Norm = select(tCtrl_Norm, contains("Rep_1"))
Rep_2_Ctrl_Norm = select(tCtrl_Norm, contains("Rep_2"))
Rep_3_Ctrl_Norm = select(tCtrl_Norm, contains("Rep_3"))
  
Rep_1_RNase_Norm = select(tRNase_Norm, contains("Rep_1"))
Rep_2_RNase_Norm = select(tRNase_Norm, contains("Rep_2"))
Rep_3_RNase_Norm = select(tRNase_Norm, contains("Rep_3")) 

  
```

```{r Fraction-wise total protein amounts Ctrl, echo=FALSE}

barplot(rowSums(Rep_1_Ctrl_Norm), las=2)
barplot(rowSums(Rep_2_Ctrl_Norm), las=2)
barplot(rowSums(Rep_3_Ctrl_Norm), las=2)

```



```{r}
Fractions = c(1:25)

MICA_HUMAN_Protein_Ctrl = ggplot() + 
  geom_line(data = select(Ctrl, contains("MICA_HUMAN_Rep_1")),  aes(x = Fractions, y = MICA_HUMAN_Rep_1, color= 'Ctrl_Rep1')) + 
  
  geom_line(data = select(Ctrl, contains("MICA_HUMAN_Rep_2")),  aes(x = Fractions, y = MICA_HUMAN_Rep_2 , color= 'Ctrl_Rep2')) + 
  
  geom_line(data = select(Ctrl, contains("MICA_HUMAN_Rep_3")),  aes(x = Fractions, y = MICA_HUMAN_Rep_3 , color= 'Ctrl_Rep3')) +
  
  scale_colour_manual(name="legend",values=c(Ctrl_Rep1="blue2",Ctrl_Rep2="purple4", Ctrl_Rep3="magenta1")) +
  
  labs(title="MICA_HUMAN_Ctrl", y= "Protein Amount") 
 MICA_HUMAN_Protein_Ctrl + scale_x_continuous(breaks = seq(1, 25, by = 1))
    
    
  
  MICA_HUMAN_Protein_Ctrl_Norm = ggplot() + 
  geom_line(data = select(tCtrl_Norm, contains("MICA_HUMAN_Rep_1")),  aes(x = Fractions, y = MICA_HUMAN_Rep_1, color= 'Ctrl_Rep1')) + 
  
  geom_line(data = select(tCtrl_Norm, contains("MICA_HUMAN_Rep_2")),  aes(x = Fractions, y = MICA_HUMAN_Rep_2 , color= 'Ctrl_Rep2')) + 
  
  geom_line(data = select(tCtrl_Norm, contains("MICA_HUMAN_Rep_3")),  aes(x = Fractions, y = MICA_HUMAN_Rep_3 , color= 'Ctrl_Rep3')) +
  
  scale_colour_manual(name="legend",values=c(Ctrl_Rep1="blue2",Ctrl_Rep2="purple4", Ctrl_Rep3="magenta1")) +
  
  labs(title="MICA_HUMAN_Ctrl_Norm", y= "Protein Amount") 
 MICA_HUMAN_Protein_Ctrl_Norm + scale_x_continuous(breaks = seq(1, 25, by = 1))
  
  
  
  
  

```
```{r}
### Second Normalization

#Mean berechnen 


Rep_1_Ctrl_Norm_Mean = data.frame(colMeans(Rep_1_Ctrl_Norm))
Rep_1_Ctrl_Norm_Mean

Rep_2_Ctrl_Norm_Mean = data.frame(rowMeans(Rep_2_Ctrl_Norm))
Rep_2_Ctrl_Norm_Mean

Rep_3_Ctrl_Norm_Mean = data.frame(rowMeans(Rep_3_Ctrl_Norm))
Rep_3_Ctrl_Norm_Mean


Rep_1_RNase_Norm_Mean = data.frame(rowMeans(Rep_1_RNase_Norm))
Rep_1_RNase_Norm_Mean

Rep_2_RNase_Norm_Mean = data.frame(rowMeans(Rep_2_RNase_Norm))
Rep_2_RNase_Norm_Mean

Rep_3_RNase_Norm_Mean = data.frame(rowMeans(Rep_3_RNase_Norm))
Rep_3_RNase_Norm_Mean


```





## Peaks Identification 

We define a threshold 



Proteins which depend on RNA are expected to migrate to different positions in the RNase treated sample in comparison to the Ctrl sample. To identify whether a protein is a RBP or not we need to detect the maxima in both samples. We want to detect both local and global maxima because even a shift of a local maximum could hold relevant biological information.
We defined a maximum as a point x whose neighboring values are smaller than it and who exceeds a threshold value of 20% of the global maximum. 

###6.3 Discussion
Defining a maximum the way we did successfully results in detecting local peaks. The threshold allows us to only detect maxima with a certain significance. However, a threshold of 20% protein value is not enough to really get only significant maxima. The significance could be further increased by comparing the values of +2  fractions from the maxima or by fitting the curve. 

```{r}
find_peaks <- function (input_df, threshold ) {
  peaks <- sapply(1:25, function(i))
```


```{r}
find_peaks <- function(x, m=2) { #The "find_peaks"-function requires a data frame ("x") and "m" as parameters
                                   peaks <- sapply(1:length(x), function(i) { #The function iterates via an "sapply" over all values (protein amounts of the fractions) in the data frame "x". All peaks that were found during this iteration will be saved in a list named "peaks"
                                    
                                                                            if (x[i] == 0) return (numeric(length = 0)) #If the value at position "i" is equal to zero the value for this position in the vector will be set as an empty value
                                                                            #In the next step the function defines the "left"- and "right"-border of the neighborhood 
                                                                            left <- max(c(1,i-m)) #For the "left"-border ("max(c(1,i-m))") of the neighborhood we get the output "1" if the value of position "i" is smaller or equal to m. Otherwise we get the value of position i minus m (i-m) as an output for the left border
                                                                            right <- min(c(i+m,length(x))) #For the "right"-border ("min(c(i+m,length(x)))") of the neighborhood the value will be set to the value of position "i" plus the threshold of the neighborhood m if i+m is smaller or equal to the value of the length of the vector "x". Otherwise the "right"-border will be set to length of the row of the data frame "x"
                                                                            
                                                                            if(all(x[left : right] <= x[i])) return(i) else return(numeric(0)) #Next we check if all values between the left and the right border are smaller or equal to the value of position "i" from the vector "x".If this is the case, the function will return the value of position "i" and otherwise it returns zero for position "i"
                                                              } #Finish inner function
                                                   ) #Finish "sapply"
                                  
                                  return(unlist(peaks)) #The final step of this function is to return the unlisted list "peaks"
} #Finish outer function

```


```{r}

max_detec_df <- function(Input_df, threshold){#Input is 3680x25 dataframe from mean, median or similmean method

  temp_df <- as.data.frame(matrix(nrow=dim(Input_df)[1], ncol = dim(Input_df)[2]))#empty dataframe
  rownames(temp_df) <- rownames(Data_copy) ###Proteins
  colnames(temp_df) <- rownames(RNase_Data_norm) ###Fractions
  j=1
  for (j in 1:dim(Input_df)[1]){#j should take the number of the line to access the line in the if statement
    i = 1 #i is the column number and is set to 1 after changing the row       
   while (i <= dim(Input_df)[2]){  #all columns are tested for one row
    if (i == 1){    #for the first column, which has a comparison element on the right only
      if(Input_df[j,i] > Input_df[j,i+1] && Input_df[j,i] > threshold * max(Input_df[j,])){
        temp_df[j,i] <- i  #the element in the new data frame is set to the maximum location (fraction number containing maximum)
      }else{
        temp_df[j,i] <- 0  #if there is no maximum the element is set to zero, so the dataframe still has the same dimension as the input
      }
    }
    if (i < dim(Input_df)[2]&& i!=1){#for fraction 2 to 24 (values right and left of the location are considered)
      if(Input_df[j,i]>Input_df[j,i+1] && Input_df[j,i]> Input_df[j,i-1] && Input_df[j,i] > threshold * max(Input_df[j,])){
        temp_df[j,i] <- i
      }else {
       temp_df[j,i] <- 0
      }
    }
    if (i == dim(Input_df)[2]){#for the 25. fraction (only left value)
      if(Input_df[j,i]>Input_df[j,i-1] && Input_df[j,i] > threshold * max(Input_df[j,])){
        temp_df[j,i] <- i
      }else{
          temp_df[j,i] <- 0
        }
      }
    i=i+1 #increasing i to move through the next column
    } 
  }   
  return(temp_df)   #at the end a data frame is returned, which contains the maxima locations for all proteins
}
```

After we execute the fraction-wise normalization the protein amount between all three Ctrl 
replicates as well as between the three RNase replicates should be equal.
In order to check if this is the case the "bar.total.prot"-function sums all normalized columns for the three Ctrl and RNase replicates and gives out a bar plot with the respective protein amount.

The bar plot shows that the amount of proteins between the three Ctrl replicate are identical. The same applies for the three RNase sample. The protein amounts between Ctrl and RNase differ from each other.


##
Main motivation is to determine the role of RNA or non coding RNA in the cell, as RNA molecules are much more than a template for protein production
screen RNA --> molecular mechanisms 
screen proteins and protein complexes (with known functions) which are interacting with RNA  --> new funcions RNA
RBPs --> RNA binding Proteins (Cancer, Neurological disorder, muscular atrophies)
IDEA: identify proteins and complexes affected by RNA
The concept of RNA dependence
A protein is definied as RNA dependent if its molecular interactions are dependent on RNA presence 
RNA dependent protein = RNA binding Proteins (RBP) + RBP-binding proteins (if RBP bound to RNA)
protein wide screen based on succrose density gradient 
Control 
proteins envolved in RNA dependent complex --> same fraction migartion
RNAse
RNA dependent protein complex  will dissociate and individual proteins will migrate in different fractions--> different fractions
Analisis of the protein content of fractions by comparing Control and RNAse samples allows identifacation of RNA dependent shifts 
Normalization is needed in order to compare the data in RNase treted and Control samples 
## 3. Peaks identification
distribution of protein in 25 fractions of both samples, Control and RNase
find global and local maxima for both 
```{r}
# Global and Maxima Detection (need to add threshold in if function)
maximafunction = function(input){
  output = 0
  for (i in 1:(length(input))){
    # 1st Fraction
    if (i == 1){
      if(input[i]<input[i+1]){
        output[i] = input[i]}
      else{
        output[i] = 0}
    }
    
    # 2nd-24th Fraction
    if (i>1 && i<length(input)){
      if(input[i]<input[i+1] && input[i]>input[i-1]){
        output[i] = input[i]}
      else{
        output[i] = 0}
    }
    
    # 25th Fraction
    if (i==length(input)){
      if(input[i]>input[i-1]){
        output[i] = input[i]
      }
      else{
        output[i] = 0}
    }
  }
  
# Only the first 2 highest values are taken. Others = 0
  for (i in 1:length(output)){
    if(output[i]==max(output) || output[i]== sort(output, decreasing = TRUE)[2]){
      output[i] = output [i]}
    else{
      output[i] = 0}
    }
  return(output)
}

# A Vector for Fraction's Names
for (i in 1:25) {
    fractionnames[i] = paste("Fraction",i,sep="_")
  }

# Results
allmaxima_Ctrl = data.frame(apply(tCtrl_Norm, 2, maximafunction), row.names = fractionnames)
allmaxima_RNase = data.frame(apply(tRNase_Norm, 2, maximafunction), row.names = fractionnames )
```
how to define a maximum in order to allow the program to find the right fraction 
t-test 
## 4. Fit of the protein profiles
## 5. 
