---
title: "Project Topic 3 Team 4"
author: "Khalida Dushimova, Madleen Piegsa, Greata Karathanos und Richard Efraim Langi"
date: "4/27/2022"
output: html_document
---
```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r}
library(cluster)
library(tidyverse) #for easy data manipulation and visualization
library(dplyr) #for the select function 
library(ggplot2)
library(factoextra) # plotting k means
```


## 1. Description of dataset (Raw data)


```{r 1.1 loading data}
#MS_Table <- read.table("~/Desktop/2022-topic-03-team-04/RDeeP_A549_NS.csv", header=TRUE, row.names=1, sep = ";")
#Richard's folder location for convenience sake :D (C:/Users/Archid Knighton/Documents/GitHub/2022-topic-03-team-04/RDeeP_A549_NS.csv)
#loading "RDeeP_A549_NS.csv" into Data.raw data frame

Data.raw <- read.table("~/Desktop/2022-topic-03-team-04/RDeeP_A549_NS.csv", header=TRUE, row.names=1, sep = ";")
#creating a copy of Data.raw and saving it as Data.copy
Data.copy = Data.raw
```



```{r}
head(Data.copy)
dim(Data.copy)
```
The data set has 150 columns and 3680 rows. 
Our first aim is to restructure the data set by fractions and divide it in two data sets, one for RNase and one for Ctrl, which will make the further analysis easier to perform. Therefor we create a resstructure fucntion.
We pick by repetitions and create Rep1, Rep2 and Rep3 vectors: starting with 1 (Ctrl) or with 2 (RNase). Every six columns there is a new fraction. 


```{r 1.2 Raw data reorganization}
restructure_func = function(input_df,start){ #start = 1 for Ctrl and start = 2 for RNase.
  Vector.Rep1 <- c(seq(from =start, to = 150, by = 6)) # by 6 to reach the next fraction 
  Vector.Rep2 <- c(seq(from =start+2, to = 150, by = 6))
  Vector.Rep3 <- c(seq(from =start+4, to = 150, by = 6))
  output_df = as.data.frame(matrix(nrow = 3*3680, ncol=25)) 
  
  
  #Naming the fractions 
  for (i in 1:25) {
    s = paste("Fraction",i,sep="_")
   colnames(output_df)[i] = s
  }
  
  
  #Assignment of values and row names
  k = 1 #Row number of the old dataframe
  i = 1 #Row number of the new dataframe
  while (i <= dim(output_df)[1]) { # All Rows of the new dataframes will be selected
    output_df[i,] = input_df[k,Vector.Rep1] #The values of Rep 1 are assigned to the row
    row.names(output_df)[i] = paste(rownames(input_df)[k],"Rep",1,sep="_") #The row is given a name of Protein_Rep_1
    i = i + 1
    
    output_df[i,] = input_df[k,Vector.Rep2] # Repeat for Rep 2
    row.names(output_df)[i] = paste(rownames(input_df)[k],"Rep",2,sep="_")
    i = i + 1
    
    output_df[i,] = input_df[k,Vector.Rep3] # Repeat for Rep 3
    row.names(output_df)[i] = paste(rownames(input_df)[k],"Rep",3,sep="_")
    i = i + 1
    
    k = k + 1 # The row of the old dataframe is advanced by 1
  }
  return(output_df)
}
Ctrl = restructure_func(Data.copy,1)
RNase = restructure_func(Data.copy,2)
```



```{r}
Ctrl = t(Ctrl)
Ctrl = data.frame(Ctrl) ## In order to be able to use the select function

RNase = t(RNase)
RNase = data.frame(RNase)
```





```{r}
Fractions = c(1:25)
MICA_HUMAN_Protein  = ggplot() +
 geom_line(data = select(Ctrl, contains("MICA_HUMAN_Rep_1")),  aes(x = Fractions, y = MICA_HUMAN_Rep_1, color= 'Ctrl_Rep1')) + 
  
  geom_line(data = select(Ctrl, contains("MICA_HUMAN_Rep_2")),  aes(x = Fractions, y = MICA_HUMAN_Rep_2, color= 'Ctrl_Rep2')) + 
  
  geom_line(data = select(Ctrl, contains("MICA_HUMAN_Rep_3")),  aes(x = Fractions, y = MICA_HUMAN_Rep_3 , color= 'Ctrl_Rep3')) +
  
  geom_line(data = select(RNase, contains("MICA_HUMAN_Rep_1")),  aes(x = Fractions, y = MICA_HUMAN_Rep_1 , color= 'RNase_Rep1')) + 
  
  geom_line(data = select(RNase, contains("MICA_HUMAN_Rep_2")), aes(x = Fractions, y = MICA_HUMAN_Rep_2, color= 'RNase_Rep2')) +
  
  geom_line(data = select(RNase, contains("MICA_HUMAN_Rep_3")), aes(x = Fractions, y = MICA_HUMAN_Rep_3 , color= 'RNase_Rep3')) +
  
  scale_colour_manual(name="legend",values=c(Ctrl_Rep1="blue2",RNase_Rep1="green4", Ctrl_Rep2="magenta1", RNase_Rep2="tomato1",Ctrl_Rep3="darkviolet", RNase_Rep3="turquoise4")) +
  
  labs(title="MICA_HUMAN_Protein_Raw", y= "Protein Amount") 
  MICA_HUMAN_Protein + scale_x_continuous(breaks = seq(1, 25, by = 1))
  
MICA_HUMAN_Protein_Ctrl = ggplot() + 
  geom_line(data = select(Ctrl, contains("MICA_HUMAN_Rep_1")),  aes(x = Fractions, y = MICA_HUMAN_Rep_1, color= 'Ctrl_Rep1')) + 
  
  geom_line(data = select(Ctrl, contains("MICA_HUMAN_Rep_2")),  aes(x = Fractions, y = MICA_HUMAN_Rep_2 , color= 'Ctrl_Rep2')) + 
  
  geom_line(data = select(Ctrl, contains("MICA_HUMAN_Rep_3")),  aes(x = Fractions, y = MICA_HUMAN_Rep_3 , color= 'Ctrl_Rep3')) +
  
  scale_colour_manual(name="legend",values=c(Ctrl_Rep1="blue2",Ctrl_Rep2="purple4", Ctrl_Rep3="magenta1")) +
  
  labs(title="MICA_HUMAN_Ctrl_Raw", y= "Protein Amount") 
 MICA_HUMAN_Protein_Ctrl + scale_x_continuous(breaks = seq(1, 25, by = 1))
  
MICA_Human_Protein_RNase = ggplot() + 
  geom_line(data = select(RNase, contains("MICA_HUMAN_Rep_1")),  aes(x = Fractions, y = MICA_HUMAN_Rep_1 , color= 'RNase_Rep1')) + 
  
  geom_line(data = select(RNase,contains("MICA_HUMAN_Rep_2")), aes(x = Fractions, y = MICA_HUMAN_Rep_2, color= 'RNase_Rep2')) +
  
  geom_line(data = select(RNase,contains("MICA_HUMAN_Rep_3")), aes(x = Fractions, y = MICA_HUMAN_Rep_3, color= 'RNase_Rep3')) +
  
   scale_colour_manual(name="legend",values=c(RNase_Rep1="blue2",RNase_Rep2="green4", RNase_Rep3= "magenta1")) +
  
  labs(title="MICA_HUMAN_RNase_Raw", y= "Protein Amount") 
  MICA_Human_Protein_RNase + scale_x_continuous(breaks = seq(1, 25, by = 1))  
```


## 2. Evaluation of the reproducibility of the experiments


---> rewrite the text!!!
To investigate the protein amount of the replicates further we sum up the total protein amount of all genes per sample replicate and plot them side by side in a bar plot. We can see that there is a huge difference between the RNase samples and also the Ctrl samples do not align.

In conclusion the protein amounts differ and are not well comparable. 

Possible causes for this fluctuation of the protein amounts lay in the experimental design of the data generation. The sucrose gradients were all produced in one step to minimize the variations. But had to be transported to the ultracentrifugation and were then fractioned by hand. And as we see the lysates can differ in their containing protein amount.


```{r}
Rep_1_Ctrl <- Ctrl %>% select(contains("Rep_1"))
Rep_1_Ctrl_sums = colSums(Rep_1_Ctrl) 
Rep_2_Ctrl <- Ctrl %>% select(contains("Rep_2"))
Rep_2_Ctrl_sums = colSums(Rep_2_Ctrl) 
Rep_3_Ctrl <- Ctrl %>% select(contains("Rep_3"))
Rep_3_Ctrl_sums = colSums(Rep_3_Ctrl) 

Rep_1_RNase <- RNase %>% select(contains("Rep_1"))
Rep_1_RNase_sums = colSums(Rep_1_RNase)
Rep_2_RNase <- RNase %>% select(contains("Rep_2"))
Rep_2_RNase_sums = colSums(Rep_2_RNase)
Rep_3_RNase <- RNase %>% select(contains("Rep_3"))
Rep_3_RNase_sums = colSums(Rep_3_RNase)

Ctrl_sums = cbind(Rep_1_Ctrl_sums, Rep_2_Ctrl_sums, Rep_3_Ctrl_sums)
RNase_sums = cbind(Rep_1_RNase_sums, Rep_2_RNase_sums, Rep_3_RNase_sums)

Ctrl_RNase_sums = cbind(Ctrl_sums, RNase_sums)

Total_Protein_amount = colSums(Ctrl_RNase_sums)
Total_Protein_amount

value = Total_Protein_amount
plotdata = data.frame(value, names=c("Ctrl1", "Ctrl2", "Ctrl3", "RNase1", "RNase2", "RNase3"))
```



```{r}
#by Madleen 
colour  = c("maroon1", "orchid3", "skyblue", "hotpink", "plum1", "skyblue1")
ggplot(plotdata, aes(names, value)) +
  geom_bar(stat = "identity", fill = colour) +
  labs( title = "Before Normalization", y = "protein value", x = "Replicates")
```

```{r}
#saving the barplot as png file
png(file="~/Desktop/2022-topic-03-team-04/barplot.before.normalization.png",
width=600, height=350)
colour  = c("maroon1", "orchid3", "skyblue", "hotpink", "plum1", "skyblue1")
ggplot(plotdata, aes(names, value)) +
  geom_bar(stat = "identity", fill = colour) +
  labs( title = "Before Normalization", y = "protein value", x = "Replicates")
```


## 2.1 Fractionwise Normalization 


```{r}
# preparation for fractionwise normalization

Rep_1_Ctrl_f = t(Rep_1_Ctrl)
Rep_1_Ctrl_fsums = colSums(Rep_1_Ctrl_f)


Rep_2_Ctrl_f = t(Rep_2_Ctrl)
Rep_2_Ctrl_fsums = colSums(Rep_2_Ctrl_f)


Rep_3_Ctrl_f = t(Rep_3_Ctrl)
Rep_3_Ctrl_fsums = colSums(Rep_3_Ctrl_f)


Rep_1_RNase_f = t(Rep_1_RNase)
Rep_1_RNase_fsums =colSums(Rep_1_RNase_f)

Rep_2_RNase_f = t(Rep_2_RNase)
Rep_2_RNase_fsums = colSums(Rep_2_RNase_f)

Rep_3_RNase_f = t(Rep_3_RNase)
Rep_3_RNase_fsums = colSums(Rep_3_RNase_f)

Total_Protein_sums = as.data.frame(colSums(Total_Protein_by_fractions))
Total_Protein_sums
```


We compute the sums fractionwise and find the two closest sums in order to define normalization factors fot the replicates. The quotients of the mean sums and sums of replicates are the noramlization factors.


```{r}
## First Normalization

Total_Protein_by_fractions_Ctrl =  cbind(Rep_1_Ctrl_fsums, Rep_2_Ctrl_fsums, Rep_3_Ctrl_fsums)
Total_Protein_by_fractions_RNase =   cbind(Rep_1_RNase_fsums, Rep_2_RNase_fsums, Rep_3_RNase_fsums)
  
Total_Protein_sums_Ctrl = as.data.frame(Total_Protein_sums[1:3,])
Total_Protein_sums_RNase = as.data.frame(Total_Protein_sums[4:6,])
mean_sums = function(x) {
  
     rep1 <- x[1,1]   
     rep2 <- x[2,1] 
     rep3 <- x[3,1]
     if( (abs(rep1-rep2)<abs(rep1-rep3)) && (abs(rep1-rep2)<abs(rep2-rep3)) ) {
        mean_sums <- mean(c(rep1,rep2))
        }
     else if( (abs(rep1-rep3)<abs(rep1-rep2)) && (abs(rep1-rep3)<abs(rep2-rep3)) ) {
       mean_sums <- mean(c(rep1,rep3))  
            }
     else {
       mean_sums <- mean(c(rep2,rep3))
     }
     
}     
     
mean_sums_Ctrl = mean_sums(Total_Protein_sums_Ctrl)
mean_sums_RNase = mean_sums(Total_Protein_sums_RNase)
    

norm_factor_ctrl <- mean_sums_Ctrl / Total_Protein_by_fractions_Ctrl


norm_factor_rnase <- mean_sums_RNase / Total_Protein_by_fractions_RNase


Rep_1_norm_Ctrl = as.data.frame(t(Rep_1_Ctrl_f)) * norm_factor_ctrl[,1]
Rep_1_norm_Ctrl_sums = rowSums(Rep_1_norm_Ctrl)

Rep_2_norm_Ctrl = as.data.frame(t(Rep_2_Ctrl_f)) * norm_factor_ctrl[,2]
Rep_2_norm_Ctrl_sums = rowSums(Rep_2_norm_Ctrl)

Rep_3_norm_Ctrl = as.data.frame(t(Rep_3_Ctrl_f)) * norm_factor_ctrl[,3]
Rep_3_norm_Ctrl_sums = rowSums(Rep_3_norm_Ctrl)

Norm_Ctrl = data.frame(cbind(Rep_1_norm_Ctrl, Rep_2_norm_Ctrl, Rep_3_norm_Ctrl))


Rep_1_norm_RNase = as.data.frame(t(Rep_1_RNase_f)) * norm_factor_rnase[,1]
Rep_1_norm_RNase_sums = rowSums(Rep_1_norm_RNase)

Rep_2_norm_RNase = as.data.frame(t(Rep_2_RNase_f)) * norm_factor_rnase[,2]
Rep_2_norm_RNase_sums = rowSums(Rep_2_norm_RNase)

Rep_3_norm_RNase = as.data.frame(t(Rep_3_RNase_f)) * norm_factor_rnase[,3]
Rep_3_norm_RNase_sums = rowSums(Rep_3_norm_RNase)

Norm_RNase = data.frame(cbind(Rep_1_norm_RNase, Rep_2_norm_RNase, Rep_3_norm_RNase))
Norm_RNase
```



```{r}
#Daten zum Ploten New Normalization

Rep_1_norm_RNase_sums = rowSums(Rep_1_norm_RNase)
Rep_2_norm_RNase_sums = rowSums(Rep_2_norm_RNase)
Rep_3_norm_RNase_sums = rowSums(Rep_3_norm_RNase)


Rep_1_norm_Ctrl_sums = rowSums(Rep_1_norm_Ctrl)
Rep_2_norm_Ctrl_sums = rowSums(Rep_2_norm_Ctrl)
Rep_3_norm_Ctrl_sums = rowSums(Rep_3_norm_Ctrl)


#by Madleen
Total_Protein_by_fractions_new = cbind(Rep_1_norm_RNase_sums,Rep_2_norm_RNase_sums, Rep_3_norm_RNase_sums, Rep_1_norm_Ctrl_sums, Rep_2_norm_Ctrl_sums, Rep_3_norm_Ctrl_sums)
Total_Protein_norm_new = t(Total_Protein_by_fractions_new)/1
Total_Protein_norm_new = as.data.frame(Total_Protein_norm_new)

Total_Protein_amount_norm_new = rowSums(Total_Protein_norm_new)

plotdata_norm_new = data.frame(Total_Protein_amount_norm_new, Replicates = c("RNase1", "RNase2", "RNase3", "Ctrl1", "Ctrl2", "Ctrl3"))
colour1  = c("maroon1", "orchid3", "skyblue", "hotpink", "plum1", "skyblue1")
ggplot(plotdata_norm_new, aes(Replicates, Total_Protein_amount_norm_new )) +
  geom_bar(stat = "identity", fill = colour) +
  labs( title = "After Normalization 1", y = "Total protein amout", x = "Replicates")

```

```{r}
#saving the barplot as png file
png(file="~/Desktop/2022-topic-03-team-04/barplot.after.first.normalization.png",
width=600, height=350)
ccolour1  = c("maroon1", "orchid3", "skyblue", "hotpink", "plum1", "skyblue1")
ggplot(plotdata_norm_new, aes(Replicates, Total_Protein_amount_norm_new )) +
  geom_bar(stat = "identity", fill = colour) +
  labs( title = "After Normalization 1", y = "Total protein amout", x = "Replicates")
```


## 2.2 Second Normalization (by Greta)


```{r by Khalida }
# in order that Gretas function works the normalized Datasets have to be reordered

Norm_Ctrl = as.data.frame(t(Norm_Ctrl))
Norm_Ctrl = Norm_Ctrl [order(rownames(Norm_Ctrl)), ]


Norm_RNase = as.data.frame(t(Norm_RNase)) 
Norm_RNase = Norm_RNase [order(rownames(Norm_RNase)), ]
```



```{r}
Norm_Ctrl

saveRDS(Norm_Ctrl, file = "Norm_Ctrl.rds")

saveRDS(Norm_RNase, file = "Norm_RNase.rds")

Data_Norm_RNase <- readRDS("Norm_RNase.rds")

Data_Norm_Ctrl <- readRDS("Norm_Ctrl.rds")

```



```{r}
#aim is to eliminate outliers in our dataset, we try to create our own function

anti_outlier_function<- function(input){
#creating the new df  
new_df_anti_outliers<- as.data.frame(matrix(nrow = (dim(input)[1]/3), ncol = dim(input)[2]))
rownames(new_df_anti_outliers) <- rownames(Data.copy)
colnames(new_df_anti_outliers) <- colnames(Data_Norm_RNase)

r<- 1   #r are the rows
while(r <= dim(input)[1]){  
  for (c in 1:dim(input)[2]){    #c are the columns
     rep1 <- input[r,c]   
     rep2 <- input[r+1,c] 
     rep3 <- input[r+2,c]
     if( (abs(rep1-rep2)<abs(rep1-rep3)) && (abs(rep1-rep2)<abs(rep2-rep3)) ) {
        mean <- mean(c(rep1,rep2))
        }
     else if( (abs(rep1-rep3)<abs(rep1-rep2)) && (abs(rep1-rep3)<abs(rep2-rep3)) ) {
       mean <- mean(c(rep1,rep3))  
            }
     else {
       mean <- mean(c(rep2,rep3))
       }
     new_df_anti_outliers[(r/3)+1,(c)] <- mean   
     }
  r <- r + 3
}

new_df_anti_outliers = new_df_anti_outliers[-dim(new_df_anti_outliers)[1],]

return(new_df_anti_outliers)
}

Ctrl_anti_outlier_df = anti_outlier_function(Data_Norm_Ctrl)
RNase_anti_outlier_df = anti_outlier_function(Data_Norm_RNase)


#dataframe combi of mean and two remaining original replicates
df_combi_function<- function(input){
#creating the new df  
new_df_combi<- as.data.frame(matrix(nrow = (dim(input)[1]), ncol = dim(input)[2])) 
rownames(new_df_combi) <- rownames(Data_Norm_Ctrl)
colnames(new_df_combi) <- colnames(Data_Norm_RNase)

r<- 1   #r are the rows
while(r<=dim(input)[1]) {  
  for (c in 1:dim(input)[2]) {    #c are the columns
     rep1 <- input[r,c]   
     rep2 <- input[r+1,c] 
     rep3 <- input[r+2,c]
     if( (abs(rep1-rep2)<abs(rep1-rep3)) && (abs(rep1-rep2)<abs(rep2-rep3)) ) {
       mean <- mean(c(rep1,rep2))
       new_df_combi[r,(c)] <- mean
       new_df_combi[r+1,(c)] <- rep1
       new_df_combi[r+2,(c)] <- rep2
       }
     else if( (abs(rep1-rep3)<abs(rep1-rep2)) && (abs(rep1-rep3)<abs(rep2-rep3)) ) {
       mean <- mean(c(rep1,rep3)) 
       new_df_combi[r,(c)] <- mean
       new_df_combi[r+1,(c)] <- rep1
       new_df_combi[r+2,(c)] <- rep3
       }
     else {
       mean <- mean(c(rep2,rep3))
       new_df_combi[r,(c)] <- mean
       new_df_combi[r+1,(c)] <- rep2
       new_df_combi[r+2,(c)] <- rep3
       }
     }
  r <- r + 3
  }
#new_df_combi = new_df_combi[-dim(new_df_combi)[1],]
return(new_df_combi)
}

Ctrl_combi_df = df_combi_function(Data_Norm_Ctrl)
RNase_combi_df = df_combi_function(Data_Norm_RNase)
Ctrl_combi_df

tCtrl_combi_df = as.data.frame(t(Ctrl_combi_df))
tRNase_combi_df = as.data.frame(t(RNase_combi_df))

# Changed: rows of last 3 loops and adds # to row 462
```



```{r}
Fractions = c(1:25)

MICA_HUMAN_Protein_Ctrl = ggplot() + 
  geom_line(data = select(Ctrl, contains("MICA_HUMAN_Rep_1")),  aes(x = Fractions, y = MICA_HUMAN_Rep_1, color= 'Ctrl_Rep1')) + 
  
  geom_line(data = select(Ctrl, contains("MICA_HUMAN_Rep_2")),  aes(x = Fractions, y = MICA_HUMAN_Rep_2 , color= 'Ctrl_Rep2')) + 
  
  geom_line(data = select(Ctrl, contains("MICA_HUMAN_Rep_3")),  aes(x = Fractions, y = MICA_HUMAN_Rep_3 , color= 'Ctrl_Rep3')) +
  
  scale_colour_manual(name="legend",values=c(Ctrl_Rep1="blue2",Ctrl_Rep2="purple4", Ctrl_Rep3="magenta1")) +
  
  labs(title="MICA_HUMAN_Ctrl_Raw", y= "Protein Amount") 
 MICA_HUMAN_Protein_Ctrl + scale_x_continuous(breaks = seq(1, 25, by = 1))
    
 
MICA_HUMAN_Protein_Ctrl_Norm_Second = ggplot() + 
  geom_line(data = select(tCtrl_combi_df, contains("MICA_HUMAN_Rep_1")),  aes(x = Fractions, y = MICA_HUMAN_Rep_1, color= 'Ctrl_Rep1')) + 
  
  geom_line(data = select(tCtrl_combi_df, contains("MICA_HUMAN_Rep_2")),  aes(x = Fractions, y = MICA_HUMAN_Rep_2 , color= 'Ctrl_Rep2')) + 
  
  geom_line(data = select(tCtrl_combi_df, contains("MICA_HUMAN_Rep_3")),  aes(x = Fractions, y = MICA_HUMAN_Rep_3 , color= 'Ctrl_Rep3')) +
  
  scale_colour_manual(name="legend",values=c(Ctrl_Rep1="blue2",Ctrl_Rep2="purple4", Ctrl_Rep3="magenta1")) +
  
  labs(title="MICA_HUMAN_Ctrl_Norm_Second", y= "Protein Amount") 
 MICA_HUMAN_Protein_Ctrl_Norm_Second + scale_x_continuous(breaks = seq(1, 25, by = 1))
 
```


## 3. Peaks Identification 



```{r}
# Global and Maxima Detection (need to add threshold in if function)
maximafunction = function(input, threshold){
  output = 0
  for (i in 1:(length(input))){
    # 1st Fraction
    if (i == 1){
      if(input[i] > input[i+1] && input[i] >= threshold*max(input)){
        output[i] = input[i]}
      else{
        output[i] = 0}
    }

    # 2nd-24th Fraction
    if (i > 1 && i < length(input)){
      if(input[i] > input[i+1] && input[i] > input[i-1] && input[i] >= threshold*max(input)){
        output[i] = input[i]}
      else{
        output[i] = 0}
    }

    # 25th Fraction
    if (i == length(input)){
      if(input[i] > input[i-1] && input[i] >= threshold*max(input)){
        output[i] = input[i]
      }
      else{
        output[i] = 0}
    }
  }
  return(output)
}


# A Vector for Fraction's Names
  fractionnames = 0
  for (i in 1:25) {
    fractionnames[i] = paste("Fraction",i,sep="_")
    }

  
# Creating Maxima Data Frames with different Threshold
for (i in seq(0.1,0.9,0.1)){
  temp = paste("maxima_Ctrl",i,sep="_")
  assign(temp, data.frame(apply(tCtrl_combi_df, 2, function(x){maximafunction(x,i)}), row.names = fractionnames))
} # Output: maxima_Ctrl_i (0.1 <= i <= 0.9)
  
for (i in seq(0.1,0.9,0.1)){
  temp = paste("maxima_RNase",i,sep="_")
  assign(temp, data.frame(apply(tRNase_combi_df, 2, function(x){maximafunction(x,i)}), row.names = fractionnames))
} # Output: maxima_RNase_i (0.1 <= i <= 0.9)


# Function to get numbers of maxima
maximanumber = function(input){
  output = 0
  temp = 0
  for (i in 1:length(input)){
    if (input[i] != 0){
      temp[i] = 1}
      else{
        temp[i] = 0}
  }
  output = sum(temp)
  return(output)
}


# Creating Vectors with numbers of Maxima
for (i in seq(0.1,0.9,0.1)){
  temp1 = paste("maxnum_Ctrl",i,sep="_")
  temp2 = get(paste("maxima_Ctrl",i,sep="_"))
  assign(temp1, apply(temp2, 2, maximanumber))
} # Output: maxnum_Ctrl_i (0.1 <= i <= 0.9)

for (i in seq(0.1,0.9,0.1)){
  temp1 = paste("maxnum_RNase",i,sep="_")
  temp2 = get(paste("maxima_RNase",i,sep="_"))
  assign(temp1, apply(temp2, 2, maximanumber))
} # Output: maxnum_RNase_i (0.1 <= i <= 0.9)
```



```{r}
# Function to plot random protein with threshold in x-axis and number of maxima in y-axis (only correctly works with input either maxnum_Ctrl_0.1 or "maxnum_RNase_0.1", nonetheless with any desired rows
# Richard's code with a couple embellishments by Madleen

maxnum_plot_col = function(){
  row = sample(1:length(maxnum_Ctrl_0.1),1)
  output1 = 0
  output1[1] = maxnum_Ctrl_0.1[row]
  for (i in seq(0.2,0.9,0.1)){
    output1[i*10] = get(paste(gsub("_0.*","","maxnum_Ctrl"),i,sep="_"))[row]
  }
  
  output2 = 0
  output2[1] = maxnum_RNase_0.1[row]
  for (i in seq(0.2,0.9,0.1)){
    output2[i*10] = get(paste(gsub("_0.*","","maxnum_RNase"),i,sep="_"))[row]
  }
  
  plot(seq(0.1,0.9,0.1),col = "red",output1, main = names(maxnum_Ctrl_0.1)[row], xlab="Threshold", ylab="Maxima Number", type="l", lwd=5)
  lines(seq(0.1,0.9,0.1),col = "blue",output2, type="l", lwd=5)
  legend("topright", legend = c("Ctrl", "RNase"), col = c("red", "blue"), lwd = c(5,5), cex = 0.75)
  
}

maxnum_plot_col()
```




```{r}
# Function to get list with only local maxima (the local maxima of all 3 reps are combined in Rep1. Rep2 and Rep3 are useless)
localmax = function(input){
  temp = list()
  for (i in 1:dim(input)[2]){
    v = input[,i]
    v = v[v < max(v)]
    temp[[i]] = v[which(v!=0)]
  }
  newtemp = list()
  j = 1
  while(j<length(temp)){
    newtemp[[j]] = c(temp[[j]],temp[[j+1]],temp[[j+2]])
    if(length(newtemp[[j]]) == 0){
      newtemp[[j]] = NA
    }
    j=j+3
  }
  # 2 dummy zeros for the last 2 elements of the list so numbers of elements are still 11040 and can use colnames from other variable without problem
  newtemp[[length(input)-1]] = 0
  newtemp[[length(input)]] = 0
  names(newtemp) = colnames(input)
  return(newtemp)
}


# List of local maxima of all threshold 
for (i in seq(0.1,0.9,0.1)){
  temp1 = paste("local_maxima_Ctrl",i,sep="_")
  temp2 = paste("maxima_Ctrl",i,sep="_")
  temp3 = localmax(get(temp2))
  assign(temp1, temp3)
} # Result: local_maxima_Ctrl_i

for (i in seq(0.1,0.9,0.1)){
  temp1 = paste("local_maxima_RNase",i,sep="_")
  temp2 = paste("maxima_RNase",i,sep="_")
  temp3 = localmax(get(temp2))
  assign(temp1, temp3)
  } # Result: local_maxima_RNase_i
```


## 4. T-Test 


T Test shows us if the global maxima of each of the proteins (all repetitions) between Ctrl and RNase group has a significance difference. A significanct difference between the 2 group will be categorized as RNA dependent and it will be our first criteria for RNA dependency.


```{r}
# Function to make data frame where absolute maxima of 3 Reps of a protein are inserted in a column
abmax = function(input){
  output = data.frame()
  i = 1
  j = 0
  while (i < dim(input)[2]){
    rep1 = max(input[,i])
    rep2 = max(input[,i+1])
    rep3 = max(input[,i+2])
    output[1:3,i-j] = c(rep1, rep2, rep3)
    colnames(output)[i-j] = gsub("_Rep_1", "", colnames(input)[i]) 
    i = i + 3
    j = j + 2
  }
  rownames(output) = c("Rep1", "Rep2","Rep3")
  return(output)
}

abmax_Ctrl = abmax(maxima_Ctrl_0.4)
abmax_RNase = abmax(maxima_RNase_0.4)

# T-Test comparing each corresponding Protein Rep of Ctrl and RNase with Bonferroni Correction
ttest = function(input1, input2, alpha){
  output = data.frame()
  for (i in 1:dim(input1)[2]){
    p = t.test(input1[,i], input2[,i], var.equal = FALSE)$p.value
    output[i,1] = p < alpha
  }
  rownames(output) = colnames(input1)
  colnames(output) = "RNA Dependency"
  return(output)
}

test = ttest(abmax_Ctrl, abmax_RNase, 0.05/dim(abmax_Ctrl)[2])
test[which(is.na(test[,1])),1] = FALSE
length(which(test == TRUE))
test
```


## 5. K-Means Clustering


Through K-Means Clustering and comparing our t test results, we define selection criteria (Y Shift and X Shift) for determining RNA dependent Proteins. Y Shift is the difference of protein amount between the global maxima of Ctrl and RNase Group. X Shift is the difference of locations of global maxima (fraction) between the global maxima of Ctrl and RNase Group. If the X and Y Shift has positive values (left and down Shift), we define the protein as RNA dependent. If the X and Y Shift has negative values or close to zero (right and up Shift), we define the protein as RNA independent. These shifts will be our second criteria for RNA dependency.


```{r}
# Y Shift
y_shift = apply(abmax_Ctrl - abmax_RNase, 2, mean)


# X Shift
rowmax_Ctrl = apply(maxima_Ctrl_0.4, 2, which.max)
rowmax_RNase = apply(maxima_RNase_0.4, 2, which.max)

meanrowmax = function(input){
  output = 0
  i = 1
  j = 0
  while (i < length(input)){
    output[i-j] = (input[i]+input[i+1]+input[i+2])/3
    names(output)[i-j] = gsub("_Rep_1", "", names(input)[i])
    i = i + 3
    j = j + 2
  }
  return(output)
}

x_shift = meanrowmax(rowmax_Ctrl) - meanrowmax(rowmax_RNase)



# Combine Y-Shift and X-Shift in a Data Frame
pxy = data.frame(X_Shift = x_shift, Y_Shift = y_shift)


# Elbow Method
wss = sapply(2:8,function(x){ 
  kmeans(pxy, x, 100)$tot.withinss
})
plot(2:8,wss,type='l',xlab="Number of Clusters", ylab="Total within-clusters Sum of Squares")


# Plotting the Clusters
## By Madleen
km = kmeans(pxy, centers = 3, nstart = 100, iter.max = 100)
fviz_cluster(km, data = pxy, geom = c("point"), main = "K Means Clustering with 3 Clusters")+
  theme(panel.background = element_rect(fill='white', colour='black'))+
  scale_colour_manual(values = c("skyblue", "orange", "red")) +
  scale_fill_manual(values = c("white", "white", "white"))+
  scale_shape_manual(values=c(19,15,17))

```
```{r}
#saving as png file
png(file="~/Desktop/2022-topic-03-team-04/kmeans.png",
width=600, height=350)
km = kmeans(pxy, centers = 3, nstart = 100, iter.max = 100)
fviz_cluster(km, data = pxy, geom = c("point"), main = "K Means Clustering with 3 Clusters")+
  theme(panel.background = element_rect(fill='white', colour='black'))+
  scale_colour_manual(values = c("skyblue", "orange", "red")) +
  scale_fill_manual(values = c("white", "white", "white"))+
  scale_shape_manual(values=c(19,15,17))
```

```{r}

png(file="~/Desktop/2022-topic-03-team-04/elbow.png",
width=600, height=350)

wss = sapply(2:8,function(x){ 
  kmeans(pxy, x, 100)$tot.withinss
})
plot(2:8,wss,type='l',xlab="Number of Clusters", ylab="Total within-clusters Sum of Squares")
```



## 6.1 Comparing RNA Dependency from both T Test and K Means


"Match" shows 1 (True) and 0 (False). True means that the results from T-Test in terms of RNA (in)dependency is the same as K-Means and the other way around for False.


```{r}
# Comparing RNA Dependency from both T Test and K Means
compare = pxy
compare[,3] = test
compare$Cluster = km$cluster

match = integer(dim(compare)[1])
names(match) = row.names(compare)

# 3 If's are made because the RNA dependent cluster's number is different every time the kmeans function runs. The number of Proteins that is categorized in the RNA dependent cluster are still the same (63).
if(length(which(compare[,4] == 1)) == 63){
  for(x in 1:dim(compare)[1]){
    if(compare[x,3] == TRUE && compare[x,4] == 1){
      match[x] = TRUE
    }
    else if(compare[x,3] == FALSE && compare[x,4] == 2){
      match[x] = TRUE
    }
    else if(compare[x,3] == FALSE && compare[x,4] == 3){
      match[x] = TRUE
    }
    else{
      match[x] = FALSE
    }
  }
}

if(length(which(compare[,4] == 2)) == 63){
  for(x in 1:dim(compare)[1]){
    if(compare[x,3] == FALSE && compare[x,4] == 1){
      match[x] = TRUE
    }
    else if(compare[x,3] == TRUE && compare[x,4] == 2){
      match[x] = TRUE
    }
    else if(compare[x,3] == FALSE && compare[x,4] == 3){
      match[x] = TRUE
    }
    else{
      match[x] = FALSE
    }
  }
}
  
if(length(which(compare[,4] == 3)) == 63){
  for(x in 1:dim(compare)[1]){
    if(compare[x,3] == FALSE && compare[x,4] == 1){
      match[x] = TRUE
    }
    else if(compare[x,3] == FALSE && compare[x,4] == 2){
      match[x] = TRUE
    }
    else if(compare[x,3] == TRUE && compare[x,4] == 3){
      match[x] = TRUE
    }
    else{
      match[x] = FALSE
    }
  }
}
```


We have defined 2 Criteria for RNA dependency. The first is the result from T Test where a significant difference of Absolute Maxima means RNA dependent. The second one is the result from K Means Clustering where Proteins that are grouped in a cluster which the majority has positive Y-Shift as RNA depedent. Below we consider 2 cases. First when both criteria are fulfilled and the other one when either criteria is satisfied.


```{r}
# Protein that is RNA dependent according to T Test and K Means Clustering (2 Criteria must be fulfilled ). A value 1 in "match" means that the Results from T-Test and K-Means are the same.
row_rnadep_2 = c()
for (i in 1:length(match)){
  if(match[i] == test[i,1]){
    row_rnadep_2 = append(row_rnadep_2, i)
  }
}
length(row_rnadep_2)


# Protein that is RNA dependent according to T Test and K Means Clustering (only 1 of the 2 Criteria must be satisfied). A value 1 in "match" means that the Results from T-Test and K-Means are the same.
rnacluster = 0
if(length(which(compare[,4] == 1)) == 63){
  rnacluster = 1
}
if(length(which(compare[,4] == 2)) == 63){
  rnacluster = 2
}
if(length(which(compare[,4] == 3)) == 63){
  rnacluster = 3
}

row_rnadep_1 = unique(sort(c(which(compare[,4] == rnacluster), which(test == TRUE))))
length(row_rnadep_1)


# Function to get which row/column of Proteins INCLUDING REPS
whichrow = function(input){
  output = c()
  for (i in 1:length(input)){
    output = append(output, (input[i]*3)-2)
    output = append(output, (input[i]*3)-1)
    output = append(output, input[i]*3)
  }
  return(output)
}
```



```{r}
# Data Frames for each RNA dependent and independent proteins (Both Conditions Fulfilled)
Ctrl_Dependent_2 = tCtrl_combi_df[,whichrow(row_rnadep_2)]
Ctrl_Independent_2 = tCtrl_combi_df[,-whichrow(row_rnadep_2)]
RNase_Dependent_2 = tRNase_combi_df[,whichrow(row_rnadep_2)]
RNase_Independent_2 = tRNase_combi_df[,-whichrow(row_rnadep_2)]

Ctrl_Dependent_Abmax_2 = abmax_Ctrl[,row_rnadep_2]
Ctrl_Independent_Abmax_2 = abmax_Ctrl[,-row_rnadep_2]
RNase_Dependent_Abmax_2 = abmax_RNase[,row_rnadep_2]
RNase_Independent_Abmax_2 = abmax_RNase[,-row_rnadep_2]

Ctrl_Dependent_Allmax_2 = maxima_Ctrl_0.4[,whichrow(row_rnadep_2)]
Ctrl_Independent_Allmax_2 = maxima_Ctrl_0.4[,-whichrow(row_rnadep_2)]
RNase_Dependent_Allmax_2 = maxima_RNase_0.4[,whichrow(row_rnadep_2)]
RNase_Independent_Allmax_2 = maxima_RNase_0.4[,-whichrow(row_rnadep_2)]


# Data Frames for each RNA dependent and independent proteins (Either Conditions Fulfilled)
Ctrl_Dependent_1 = tCtrl_combi_df[,whichrow(row_rnadep_1)]
Ctrl_Independent_1 = tCtrl_combi_df[,-whichrow(row_rnadep_1)]
RNase_Dependent_1 = tRNase_combi_df[,whichrow(row_rnadep_1)]
RNase_Independent_1 = tRNase_combi_df[,-whichrow(row_rnadep_1)]

Ctrl_Dependent_Abmax_1 = abmax_Ctrl[,row_rnadep_1]
Ctrl_Independent_Abmax_1 = abmax_Ctrl[,-row_rnadep_1]
RNase_Dependent_Abmax_1 = abmax_RNase[,row_rnadep_1]
RNase_Independent_Abmax_1 = abmax_RNase[,-row_rnadep_1]

Ctrl_Dependent_Allmax_1 = maxima_Ctrl_0.4[,whichrow(row_rnadep_1)]
Ctrl_Independent_Allmax_1 = maxima_Ctrl_0.4[,-whichrow(row_rnadep_1)]
RNase_Dependent_Allmax_1 = maxima_RNase_0.4[,whichrow(row_rnadep_1)]
RNase_Independent_Allmax_1 = maxima_RNase_0.4[,-whichrow(row_rnadep_1)]
```


## 6.2 Comparing with Data Bank


```{r}
# Protein names and number of times listed as RBP from data bank is taken and put into new data frame

#

Data.RBPResearch <- read.table("~/Desktop/2022-topic-03-team-04/table_RBP_lists.csv", header=FALSE, sep = ",")

databank = data.frame(matrix(nrow=5004, ncol=2))

i=31
j=1
while (i<dim(Data.RBPResearch)[1]){
  databank[((i-(24*j))/7*j),1] = Data.RBPResearch[i,1]
  databank[((i-(24*j))/7*j),2] = Data.RBPResearch[i+3,1]
  j= j +1
  i = i+24
}
temp_name = databank[,1]
databank = as.integer(databank[,2])
names(databank) = temp_name

# Take only proteins that are at least one time identified as RBP from databank
databank_value = databank[-which(databank == 0)]


# Check how many RNA dependent proteins (2 conditions fulfilled) that are identified through our code and from data bank
temporary_2 = colnames(Ctrl_Dependent_Abmax_2)
temporary_2 = append(temporary_2, numeric(length(databank_value - length(temporary_2))))

RDeep_2 = intersect(names(databank_value), temporary_2)
length(RDeep_2)


# Check how many RNA dependent proteins (either condition fulfilled) that are identified through our code and from data bank
temporary_1 = colnames(Ctrl_Dependent_Abmax_1)
temporary_1 = append(temporary_1, numeric(length(databank_value - length(temporary_1))))

RDeep_1 = intersect(names(databank_value), temporary_1)
length(RDeep_1)
```



```{r}

# Check how many RNA dependent proteins were not identified 
temporary_none = colnames(Ctrl_Independent_Abmax_2)
temporary_none = append(temporary_none, numeric(length(databank_value -length(temporary_none))))
Not_identified_RDeep = intersect(names(databank_value), temporary_none)
length(Not_identified_RDeep)
```


Too many RNA dependent proteins were not identified (2031), so we have to try to find more Maxima and more potential dependent proteins, we can apply our criteria on 
--> local maxima detection and applying our criteria on detected values


## 7.1 T Test of Local Maxima


```{r}
# T-Test function for local maxima
localtest = function(input1, input2){
  i = 1
  j = 0
  p = c()
  output = c()
  while(i < length(input1)){
  # if NA or only one local maxima exists, it is impossible to do T-Test because there is no standard deviation
    if(all(is.na(input1[[i]])) || all(is.na(input2[[i]])) || length(input1[[i]])<2 || length(input2[[i]])<2){
      p[i-j] = NA
      i = i+3
      j = j+2
      }
    else{
    p[i-j] = t.test(input1[[i]], input2[[i]], var.equal = F)$p.value
    i = i+3
    j = j+2
    }
  }
  # Bonferonni Correction
  output = p < 0.05/(length(p)-length(which(is.na(p))))
  # Dummy NA for last proteins with no result from t-test. R somehow remove all last NA. 
  if(length(output) != length(colnames(abmax_Ctrl))){
    output = append(output, rep(NA, length(colnames(abmax_Ctrl)) - length(output)))
  }
  names(output) = colnames(abmax_Ctrl)
  output = as.data.frame(output)
  return(output)
}


# T Test results from different threshold
for (i in seq(0.1, 0.9, 0.1)){
  temp1 = paste("local_maxima_Ctrl",i,sep="_")
  temp2 = paste("local_maxima_RNase",i,sep="_")
  temp3 = paste("test",i,sep="_")
  assign(temp3, localtest(get(temp1), get(temp2)))
} # Result: test_i


# Check which threshold identifies the most RNA dependent proteins
true_num = c()
for (i in seq(0.1, 0.9, 0.1)){
  temp = get(paste("test",i,sep="_"))
  true_num[i*10] = length(which(temp[,1] != 0))
}
names(true_num) = c(seq(0.1, 0.9, 0.1))
which.max(true_num)


local_maxima_Rdeep = rownames(test_0.4)[which(test_0.4 == TRUE)]
length(local_maxima_Rdeep)
```

--> kurze Beschreibung dazu, die dann in Report kommt

## 7.2 T Test results of local maxima will be the 3rd criteria


```{r}
# Check how many RNA dependent proteins (either of the 3 conditions fulfilled) that are identified through our code and from data bank 

temporary_3 = colnames(Ctrl_Dependent_Abmax_1)
temporary_3 = unique(sort(append(temporary_3, local_maxima_Rdeep)))

RDeep_3 = intersect(names(databank_value), temporary_3)
length(RDeep_3)


# Find which row of the proteins fulfill either of the 3 conditions
row_rnadep_3 = row_rnadep_1
row_rnadep_3 = unique(sort(append(row_rnadep_3, which(test_0.4 == TRUE))))


# Find which proteins doesn't fulfill either of the 3 conditions
row_notrnadep_3 = setdiff(1:3680, row_rnadep_3)
NotRDeep_3 = rownames(test_0.4)[row_notrnadep_3]


# Check how many RNA dependent proteins were not identified 
Not_identified_RDeep_3 = intersect(names(databank_value), NotRDeep_3)
length(Not_identified_RDeep_3)
```


## Further Databank by Khalida
```{r}
load("~/Desktop/2022-topic-03-team-04/HS_RBPs.RData")

load("~/Desktop/2022-topic-03-team-04/HS_non_RBPs.RData")

```


## 8.1 Linear Regression (Using Correlation to Predict Y Shift)


Ctrl and RNase should have lower correlation for RNA dependent than RNA indepedent.


```{r}
# Function to get the mean of 3 Reps
mean_rep = function(input){
  output = data.frame(matrix(nrow=25, ncol=3680))
  colnames(output) = colnames(abmax_Ctrl)
  j = 0
  i = 1
  temp = 0
  while (i<=dim(input)[2]){
    temp = (input[,i] + input[,i+1] + input[,i+2])/3
    output[,i-j] = temp
    i = i+3
    j = j+2
    
  }
  return(output)
}

Ctrl_mean = mean_rep(tRNase_combi_df)
RNase_mean = mean_rep(tCtrl_combi_df)


# Remove proteins that have constant value from Ctrl- and RNase_mean
const_row = which(sapply(1:dim(Ctrl_mean)[2], function(x){length(unique(Ctrl_mean[,x])) == 1})) # Only use from Ctrl because RNase have 1 constant protein and also the same in Ctrl

Ctrl_mean = Ctrl_mean[,-const_row]
RNase_mean = RNase_mean[,-const_row]


# Correlation between Ctrl and RNase Group
cor = c()
for (i in 1:dim(Ctrl_mean)[2]){
  cor[i] = cor(Ctrl_mean[,i], RNase_mean[,i]) 
}
names(cor) = colnames(Ctrl_mean)


# Remove proteins that have constant value from Y-Shift
y_shift_no_const = y_shift[-const_row]


# Linear Regression between correlation (X Axis) and Y-Shift (Y Axis)
df_lm = data.frame(Y_Shift = y_shift_no_const, Correlation = cor)
train_df = df_lm[1:round(0.8*dim(df_lm)[1]),]
test_df = df_lm[(dim(train_df)[1]+1):dim(df_lm)[1],]
lm = lm(Y_Shift ~ Correlation, data = train_df)
summary(lm)


# Plot Linear Regression (Error is caused by logarithming negative values and can be ignored. Logarithming make visualization better)
ggplot(data = train_df, aes(x = Correlation, y = Y_Shift)) +
  geom_point(color="blue") +
  scale_x_continuous(trans = "log10") +
  scale_y_continuous(trans = "log10") +
  geom_smooth(method="lm", color="red")


# Plot Residuals
hist(lm$residuals, breaks = 20)
qqnorm(lm$residuals)
qqline(lm$residuals)


# Linear Regression first Prerequisite (Correlation between residuals and x values is 0)
cor(train_df$Correlation, lm$residuals)


# Linear Regression second Prerequisite (Correlation between expected y and x values is 1)
cor(train_df$Correlation*lm$coefficients[2] + lm$coefficients[1], train_df$Correlation)


# Testing Linear Model
test_model <- predict.lm(lm, test_df)


# Plot actual value (x Axis) against predicted Value (y Axis) 
compare_df = data.frame(actual_value = test_df$Y_Shift, predicted_value = test_model)
ggplot(data = compare_df, aes(x = actual_value, y = predicted_value)) +
  geom_point() +
  geom_abline(intercept = 0, slope = 1)
```


## 8.2 Linear Regression using RBP2GO_Score to Predict X Shift (by Richard)


After testing multiplte variables from the new data bank and the data that we have, we decide to use these 2 variables because they have low correlation and a p value that is less than 0.05 in linear regression. 


```{r}
# HS_RBPs and HS_non_RBPs are the new data bank (data frame)
load("~/Desktop/2022-topic-03-team-04/HS_RBPs.RData")


# Find which protein in the new data bank is the same as our y shift

protein_same_rbp = sort(intersect(HS_RBPs[,3], names(y_shift)))
temp_row_y_shift = c()
temp_row_databank = c()

for (i in 1:length(protein_same_rbp)){
  temp_row_y_shift[i] = which(protein_same_rbp[i] == names(y_shift))
}

for (i in 1:length(protein_same_rbp)){
  temp_row_databank[i] = which(protein_same_rbp[i] == HS_RBPs[,3])
}


# Create data frame with y shift and data from data bank
df_lm_4 = data.frame(Y_Shift = y_shift[temp_row_y_shift], RBP2GO_Score = HS_RBPs$RBP2GO_Score[temp_row_databank], Listing_Count = HS_RBPs$Listing_Count[temp_row_databank], AVG10_Int_Listing_Count = HS_non_RBPs$AVG10_Int_Listing_Count[temp_row_databank], Mass_kDa = HS_non_RBPs$Mass_kDa[temp_row_databank], Length_AA = HS_non_RBPs$Length_AA[temp_row_databank], X_Shift = x_shift[temp_row_y_shift])


# Linear Regression
train_df_4 = df_lm_4[1:round(0.8*dim(df_lm_4)[1]),]
test_df_4 = df_lm_4[(dim(train_df_4)[1]+1):dim(df_lm_4)[1],]
lm_4 = lm(X_Shift ~ RBP2GO_Score , data = train_df_4)
summary(lm_4)


# Plot Linear Regression
ggplot(data = train_df_4, aes(x = RBP2GO_Score, y = X_Shift)) +
  geom_point(color="blue") +
  geom_smooth(method="lm", color="red")


# Plot Residuals
hist(lm_4$residuals, breaks = 20)
qqnorm(lm_4$residuals)
qqline(lm_4$residuals)


# Linear Regression first Prerequisite (Correlation between residuals and x values is 0)
cor(train_df_4$RBP2GO_Score, lm_4$residuals)


# Linear Regression second Prerequisite (Correlation between expected y and x values is 1)
cor(train_df_4$RBP2GO_Score*lm_4$coefficients[2] + lm_4$coefficients[1], train_df_4$RBP2GO_Score)


# Testing Linear Model
test_model_4 <- predict.lm(lm_4, test_df_4)


# Plot actual value (x Axis) against predicted Value (y Axis) 
compare_df_4 = data.frame(actual_value = test_df_4$X_Shift, predicted_value = test_model_4)
ggplot(data = compare_df_4, aes(x = actual_value, y = predicted_value)) +
  geom_point() +
  geom_abline(intercept = 0, slope = 1)
```
--> Wozu wurde es gemacht???



