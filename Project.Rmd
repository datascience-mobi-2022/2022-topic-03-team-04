---
title: "Project Topic 3 Team 4"
author: "Khalida Dushimova, Madleen Piegsa, Greata Karathanos und Richard Efraim Langi"
date: "4/27/2022"
output: html_document
---
```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r}
library(tidyverse)
library(heatmaply)
library(scales)
library(gganimate)
library(dplyr) ##for the select function 
library(tibble)
library(ggiraph)
library(ggiraphExtra)
library(ggplot2)
library(qqplotr)
library(circlize)
library(plyr)
```


## 1. Description of dataset (Raw data)


```{r 1.1 loading data}
#MS_Table <- read.table("~/Desktop/2022-topic-03-team-04/RDeeP_A549_NS.csv", header=TRUE, row.names=1, sep = ";")
#Richard's folder location for convenience sake :D (C:/Users/Archid Knighton/Documents/GitHub/2022-topic-03-team-04/RDeeP_A549_NS.csv)
#loading "RDeeP_A549_NS.csv" into Data.raw data frame

Data.raw <- read.table("C:/Users/Archid Knighton/Documents/GitHub/2022-topic-03-team-04/RDeeP_A549_NS.csv", header=TRUE, row.names=1, sep = ";")

#creating a copy of Data.raw and saving it as Data.copy
Data.copy = Data.raw
```



```{r}
head(Data.copy)
dim(Data.copy)
# the data set has 150 columns and 3680 rows
# restructuring needed 
# we want to restructure the data set by fractions and divide it in two data sets, one for RNase and one for Ctrl
# we need to write a function that restructures the data set
## Therefor we pick by repetitions and create Rep1, Rep2 and Rep3 vectors:starting with 1 (Ctrl) or with 2 (RNase) 
## every six columns there is a new fraction 
```



```{r 1.2 Raw data reorganization}
restructure_func = function(input_df,start){ #start = 1 for Ctrl and start = 2 for RNase.
  Vector.Rep1 <- c(seq(from =start, to = 150, by = 6)) # by 6 to reach the next fraction 
  Vector.Rep2 <- c(seq(from =start+2, to = 150, by = 6))
  Vector.Rep3 <- c(seq(from =start+4, to = 150, by = 6))
  output_df = as.data.frame(matrix(nrow = 3*3680, ncol=25)) 
  
  
  #Naming the fractions 
  for (i in 1:25) {
    s = paste("Fraction",i,sep="_")
   colnames(output_df)[i] = s
  }
  
  
  #Assignment of values and row names
  k = 1 #Row number of the old dataframe
  i = 1 #Row number of the new dataframe
  while (i <= dim(output_df)[1]) { # All Rows of the new dataframes will be selected
    output_df[i,] = input_df[k,Vector.Rep1] #The values of Rep 1 are assigned to the row
    row.names(output_df)[i] = paste(rownames(input_df)[k],"Rep",1,sep="_") #The row is given a name of Protein_Rep_1
    i = i + 1
    
    output_df[i,] = input_df[k,Vector.Rep2] # Repeat for Rep 2
    row.names(output_df)[i] = paste(rownames(input_df)[k],"Rep",2,sep="_")
    i = i + 1
    
    output_df[i,] = input_df[k,Vector.Rep3] # Repeat for Rep 3
    row.names(output_df)[i] = paste(rownames(input_df)[k],"Rep",3,sep="_")
    i = i + 1
    
    k = k + 1 # The row of the old dataframe is advanced by 1
  }
  return(output_df)
}
Ctrl = restructure_func(Data.copy,1)
RNase = restructure_func(Data.copy,2)
```



```{r}
Ctrl = t(Ctrl)
Ctrl = data.frame(Ctrl) ## In order to be able to use the select function

RNase = t(RNase)
RNase = data.frame(RNase)
```



```{r Plots for SPB6_Human_Protein}
Fractions = c(1:25)
SPB6_Human_Protein_Ctrl = ggplot() + 
  geom_line(data = select(Ctrl,1),  aes(x = Fractions, y = SPB6_HUMAN_Rep_1, color= 'Ctrl_Rep1')) + 
  
  geom_line(data = select(Ctrl,2),  aes(x = Fractions, y = SPB6_HUMAN_Rep_2 , color= 'Ctrl_Rep2')) + 
  
  geom_line(data = select(Ctrl,3),  aes(x = Fractions, y = SPB6_HUMAN_Rep_3 , color= 'Ctrl_Rep3')) +
  
  scale_colour_manual(name="legend",values=c(Ctrl_Rep1="blue2",Ctrl_Rep2="cyan3", Ctrl_Rep3="violetred4")) +
  
  labs(title="SPB6_HUMAN_Ctrl", y= "Protein Amount") 
 SPB6_Human_Protein_Ctrl + scale_x_continuous(breaks = seq(1, 25, by = 1))
  
  
SPB6_Human_Protein_RNase = ggplot() + 
  geom_line(data = select(RNase,1),  aes(x = Fractions, y = SPB6_HUMAN_Rep_1 , color= 'RNase_Rep1')) + 
  
  geom_line(data = select(RNase,2), aes(x = Fractions, y = SPB6_HUMAN_Rep_2, color= 'RNase_Rep2')) +
  
  geom_line(data = select(RNase,3), aes(x = Fractions, y = SPB6_HUMAN_Rep_3, color= 'RNase_Rep3')) +
  
   scale_colour_manual(name="legend",values=c(RNase_Rep1="blue2",RNase_Rep2="cyan3", RNase_Rep3= "violetred4")) +
  
  labs(title="SPB6_HUMAN_RNase", y= "Protein Amount") 
  SPB6_Human_Protein_RNase + scale_x_continuous(breaks = seq(1, 25, by = 1))
  

SPB6_Human_Protein = ggplot() +
 geom_line(data = select(Ctrl,1),  aes(x = Fractions, y = SPB6_HUMAN_Rep_1, color= 'Ctrl_Rep1')) + 
  
  geom_line(data = select(Ctrl,2),  aes(x = Fractions, y = SPB6_HUMAN_Rep_2 , color= 'Ctrl_Rep2')) + 
  
  geom_line(data = select(Ctrl,3),  aes(x = Fractions, y = SPB6_HUMAN_Rep_3 , color= 'Ctrl_Rep3')) +
  
  geom_line(data = select(RNase,1),  aes(x = Fractions, y = SPB6_HUMAN_Rep_1 , color= 'RNase_Rep1')) + 
  
  geom_line(data = select(RNase,2), aes(x = Fractions, y = SPB6_HUMAN_Rep_2, color= 'RNase_Rep2')) +
  
  geom_line(data = select(RNase,3), aes(x = Fractions, y = SPB6_HUMAN_Rep_3 , color= 'RNase_Rep3')) +
  
  scale_colour_manual(name="legend",values=c(Ctrl_Rep1="blue2",RNase_Rep1="cyan3", Ctrl_Rep2="violetred4", RNase_Rep2="tomato1",Ctrl_Rep3="darkviolet", RNase_Rep3="pink")) +
  
  labs(title="SPB6_HUMAN", y= "Protein Amount") 
  SPB6_Human_Protein + scale_x_continuous(breaks = seq(1, 25, by = 1))
 
# RNA associates with proteins to form RNA-Protein complexes that play key regulatory roles in cellular processes --> RNA metabolism and the regulation of gene expression 
# concept of RNA dependence (R-DeeP) describes proteins and protein complexes whose interactions are directly or indirectly dependent on the presence of RNA 
# aim: identify RNA-dependent proteins from the position of the proteins in an untreated cell lysate as t
```



```{r}
Fractions = c(1:25)
MICA_HUMAN_Protein  = ggplot() +
 geom_line(data = select(Ctrl, contains("MICA_HUMAN_Rep_1")),  aes(x = Fractions, y = MICA_HUMAN_Rep_1, color= 'Ctrl_Rep1')) + 
  
  geom_line(data = select(Ctrl, contains("MICA_HUMAN_Rep_2")),  aes(x = Fractions, y = MICA_HUMAN_Rep_2, color= 'Ctrl_Rep2')) + 
  
  geom_line(data = select(Ctrl, contains("MICA_HUMAN_Rep_3")),  aes(x = Fractions, y = MICA_HUMAN_Rep_3 , color= 'Ctrl_Rep3')) +
  
  geom_line(data = select(RNase, contains("MICA_HUMAN_Rep_1")),  aes(x = Fractions, y = MICA_HUMAN_Rep_1 , color= 'RNase_Rep1')) + 
  
  geom_line(data = select(RNase, contains("MICA_HUMAN_Rep_2")), aes(x = Fractions, y = MICA_HUMAN_Rep_2, color= 'RNase_Rep2')) +
  
  geom_line(data = select(RNase, contains("MICA_HUMAN_Rep_3")), aes(x = Fractions, y = MICA_HUMAN_Rep_3 , color= 'RNase_Rep3')) +
  
  scale_colour_manual(name="legend",values=c(Ctrl_Rep1="blue2",RNase_Rep1="green4", Ctrl_Rep2="magenta1", RNase_Rep2="tomato1",Ctrl_Rep3="darkviolet", RNase_Rep3="turquoise4")) +
  
  labs(title="MICA_HUMAN_Protein", y= "Protein Amount") 
  MICA_HUMAN_Protein + scale_x_continuous(breaks = seq(1, 25, by = 1))
  
MICA_HUMAN_Protein_Ctrl = ggplot() + 
  geom_line(data = select(Ctrl, contains("MICA_HUMAN_Rep_1")),  aes(x = Fractions, y = MICA_HUMAN_Rep_1, color= 'Ctrl_Rep1')) + 
  
  geom_line(data = select(Ctrl, contains("MICA_HUMAN_Rep_2")),  aes(x = Fractions, y = MICA_HUMAN_Rep_2 , color= 'Ctrl_Rep2')) + 
  
  geom_line(data = select(Ctrl, contains("MICA_HUMAN_Rep_3")),  aes(x = Fractions, y = MICA_HUMAN_Rep_3 , color= 'Ctrl_Rep3')) +
  
  scale_colour_manual(name="legend",values=c(Ctrl_Rep1="blue2",Ctrl_Rep2="purple4", Ctrl_Rep3="magenta1")) +
  
  labs(title="MICA_HUMAN_Ctrl", y= "Protein Amount") 
 MICA_HUMAN_Protein_Ctrl + scale_x_continuous(breaks = seq(1, 25, by = 1))
  
MICA_Human_Protein_RNase = ggplot() + 
  geom_line(data = select(RNase, contains("MICA_HUMAN_Rep_1")),  aes(x = Fractions, y = MICA_HUMAN_Rep_1 , color= 'RNase_Rep1')) + 
  
  geom_line(data = select(RNase,contains("MICA_HUMAN_Rep_2")), aes(x = Fractions, y = MICA_HUMAN_Rep_2, color= 'RNase_Rep2')) +
  
  geom_line(data = select(RNase,contains("MICA_HUMAN_Rep_3")), aes(x = Fractions, y = MICA_HUMAN_Rep_3, color= 'RNase_Rep3')) +
  
   scale_colour_manual(name="legend",values=c(RNase_Rep1="blue2",RNase_Rep2="green4", RNase_Rep3= "magenta1")) +
  
  labs(title="MICA_HUMAN_RNase", y= "Protein Amount") 
  MICA_Human_Protein_RNase + scale_x_continuous(breaks = seq(1, 25, by = 1))  
```


## 1. Evaluation of the reproducibility of the experiments 


To investigate the protein amount of the replicates further we sum up the total protein amount of all genes per sample replicate and plot them side by side in a bar plot. We can see that there is a huge difference between the RNase samples and also the Ctrl samples do not align.

In conclusion the protein amounts differ and are not well comparable. 

Possible causes for this fluctuation of the protein amounts lay in the experimental design of the data generation. The sucrose gradients were all produced in one step to minimize the variations. But had to be transported to the ultracentrifugation and were then fractioned by hand. And as we see the lysates can differ in their containing protein amount.


```{r}
Rep_1_Ctrl <- Ctrl %>% select(contains("Rep_1"))
Rep_1_Ctrl_sums = colSums(Rep_1_Ctrl) 
Rep_2_Ctrl <- Ctrl %>% select(contains("Rep_2"))
Rep_2_Ctrl_sums = colSums(Rep_2_Ctrl) 
Rep_3_Ctrl <- Ctrl %>% select(contains("Rep_3"))
Rep_3_Ctrl_sums = colSums(Rep_3_Ctrl) 

Rep_1_RNase <- RNase %>% select(contains("Rep_1"))
Rep_1_RNase_sums = colSums(Rep_1_RNase)
Rep_2_RNase <- RNase %>% select(contains("Rep_2"))
Rep_2_RNase_sums = colSums(Rep_2_RNase)
Rep_3_RNase <- RNase %>% select(contains("Rep_3"))
Rep_3_RNase_sums = colSums(Rep_3_RNase)

Ctrl_sums = cbind(Rep_1_Ctrl_sums, Rep_2_Ctrl_sums, Rep_3_Ctrl_sums)
RNase_sums = cbind(Rep_1_RNase_sums, Rep_2_RNase_sums, Rep_3_RNase_sums)

Ctrl_RNase_sums = cbind(Ctrl_sums, RNase_sums)

Total_Protein_amount = colSums(Ctrl_RNase_sums)
Total_Protein_amount

value = Total_Protein_amount
plotdata = data.frame(value, names=c("Ctrl1", "Ctrl2", "Ctrl3", "RNase1", "RNase2", "RNase3"))
```



```{r}
#by Madleen 
colour  = c("maroon1", "orchid3", "skyblue", "hotpink", "plum1", "skyblue1")
ggplot(plotdata, aes(names, value)) +
  geom_bar(stat = "identity", fill = colour) +
  labs( title = "Before Normalization", y = "protein value", x = "Replicates")
```


## 2.1 Normalization (Fractionwise, first try) by Khalida 


```{r}
Rep_1_Ctrl_f = t(Rep_1_Ctrl)
Rep_1_Ctrl_fsums = colSums(Rep_1_Ctrl_f)


Rep_2_Ctrl_f = t(Rep_2_Ctrl)
Rep_2_Ctrl_fsums = colSums(Rep_2_Ctrl_f)


Rep_3_Ctrl_f = t(Rep_3_Ctrl)
Rep_3_Ctrl_fsums = colSums(Rep_3_Ctrl_f)


Rep_1_RNase_f = t(Rep_1_RNase)
Rep_1_RNase_fsums =colSums(Rep_1_RNase_f)

Rep_2_RNase_f = t(Rep_2_RNase)
Rep_2_RNase_fsums = colSums(Rep_2_RNase_f)

Rep_3_RNase_f = t(Rep_3_RNase)
Rep_3_RNase_fsums = colSums(Rep_3_RNase_f)

Total_Protein_by_fractions = cbind(Rep_1_Ctrl_fsums,Rep_2_Ctrl_fsums, Rep_3_Ctrl_fsums, Rep_1_RNase_fsums, Rep_2_RNase_fsums, Rep_3_RNase_fsums)


Total_Protein_norm = t(Total_Protein_by_fractions)/Total_Protein_amount
Total_Protein_norm = as.data.frame(Total_Protein_norm)
Total_Protein_norm

Total_Protein_amount_norm = rowSums(Total_Protein_norm)


Total_Protein_amount_norm
plotdata_norm = data.frame(Total_Protein_amount_norm, Replicates = c("Ctrl1", "Ctrl2", "Ctrl3", "RNase1", "RNase2", "RNase3"))

#by Madleen 
colour1  = c("maroon1", "orchid3", "skyblue", "hotpink", "plum1", "skyblue1")
ggplot(plotdata_norm, aes(Replicates, Total_Protein_amount_norm )) +
  geom_bar(stat = "identity", fill = colour) +
  labs( title = "After Normalization 1", y = "Total protein amout", x = "Replicates")


## same concept but in general function 
norm_func = function(x) { 
  x/sum(x) 
}

# Applying the normalization to the data
RNase_Data_norm = data.frame(apply(RNase, 1, norm_func))


Ctrl_Data_norm = data.frame(apply(Ctrl, 1, norm_func))


#Remove the NAs that result from some proteins having 0 Protein amount in certain repetitions.
Ctrl_Data_norm[is.na(Ctrl_Data_norm)] <- 0
Ctrl_Data_norm
tCtrl_Norm <- as.data.frame(t(Ctrl_Data_norm))
tCtrl_Norm

RNase_Data_norm[is.na(RNase_Data_norm)] <- 0
RNase_Data_norm
tRNase_Norm <- as.data.frame(t(RNase_Data_norm))
tRNase_Norm
```


Working with ratio --> not practical 
The same fraction amount of 2 proteins can differ in ratio because it depends on the total amount

Goal: all Replicates have the same amount of protein, but we are working with protein number and not ratio 


```{r}
Total_Protein_sums = as.data.frame(colSums(Total_Protein_by_fractions))
Total_Protein_sums
```


We compute the sums fractionwise and find the two closest sums in order to define normalization factors fot the replicates. The quotients of the mean sums and sums of replicates are the noramlization factors.
```{r}
## New Normalization

Total_Protein_by_fractions_Ctrl =  cbind(Rep_1_Ctrl_fsums, Rep_2_Ctrl_fsums, Rep_3_Ctrl_fsums)
Total_Protein_by_fractions_RNase =   cbind(Rep_1_RNase_fsums, Rep_2_RNase_fsums, Rep_3_RNase_fsums)
  
Total_Protein_sums_Ctrl = as.data.frame(Total_Protein_sums[1:3,])
Total_Protein_sums_RNase = as.data.frame(Total_Protein_sums[4:6,])
mean_sums = function(x) {
  
     rep1 <- x[1,1]   
     rep2 <- x[2,1] 
     rep3 <- x[3,1]
     if( (abs(rep1-rep2)<abs(rep1-rep3)) && (abs(rep1-rep2)<abs(rep2-rep3)) ) {
        mean_sums <- mean(c(rep1,rep2))
        }
     else if( (abs(rep1-rep3)<abs(rep1-rep2)) && (abs(rep1-rep3)<abs(rep2-rep3)) ) {
       mean_sums <- mean(c(rep1,rep3))  
            }
     else {
       mean_sums <- mean(c(rep2,rep3))
     }
     
}     
     
mean_sums_Ctrl = mean_sums(Total_Protein_sums_Ctrl)
mean_sums_RNase = mean_sums(Total_Protein_sums_RNase)
    

norm_factor_ctrl <- mean_sums_Ctrl / Total_Protein_by_fractions_Ctrl


norm_factor_rnase <- mean_sums_RNase / Total_Protein_by_fractions_RNase


Rep_1_norm_Ctrl = as.data.frame(t(Rep_1_Ctrl_f)) * norm_factor_ctrl[,1]
Rep_1_norm_Ctrl_sums = rowSums(Rep_1_norm_Ctrl)

Rep_2_norm_Ctrl = as.data.frame(t(Rep_2_Ctrl_f)) * norm_factor_ctrl[,2]
Rep_2_norm_Ctrl_sums = rowSums(Rep_2_norm_Ctrl)

Rep_3_norm_Ctrl = as.data.frame(t(Rep_3_Ctrl_f)) * norm_factor_ctrl[,3]
Rep_3_norm_Ctrl_sums = rowSums(Rep_3_norm_Ctrl)

Norm_Ctrl = data.frame(cbind(Rep_1_norm_Ctrl, Rep_2_norm_Ctrl, Rep_3_norm_Ctrl))


Rep_1_norm_RNase = as.data.frame(t(Rep_1_RNase_f)) * norm_factor_rnase[,1]
Rep_1_norm_RNase_sums = rowSums(Rep_1_norm_RNase)

Rep_2_norm_RNase = as.data.frame(t(Rep_2_RNase_f)) * norm_factor_rnase[,2]
Rep_2_norm_RNase_sums = rowSums(Rep_2_norm_RNase)

Rep_3_norm_RNase = as.data.frame(t(Rep_3_RNase_f)) * norm_factor_rnase[,3]
Rep_3_norm_RNase_sums = rowSums(Rep_3_norm_RNase)

Norm_RNase = data.frame(cbind(Rep_1_norm_RNase, Rep_2_norm_RNase, Rep_3_norm_RNase))
Norm_RNase
```



```{r}
#Daten zum Ploten New Normalization

Rep_1_norm_RNase_sums = rowSums(Rep_1_norm_RNase)
Rep_1_norm_RNase_sums
Rep_2_norm_RNase_sums = rowSums(Rep_2_norm_RNase)
Rep_2_norm_RNase_sums
Rep_3_norm_RNase_sums = rowSums(Rep_3_norm_RNase)
Rep_3_norm_RNase_sums

Rep_1_norm_Ctrl_sums = rowSums(Rep_1_norm_Ctrl)
Rep_1_norm_Ctrl_sums
Rep_2_norm_Ctrl_sums = rowSums(Rep_2_norm_Ctrl)
Rep_2_norm_Ctrl_sums
Rep_3_norm_Ctrl_sums = rowSums(Rep_3_norm_Ctrl)
Rep_3_norm_Ctrl_sums


#by Madleen
Total_Protein_by_fractions_new = cbind(Rep_1_norm_RNase_sums,Rep_2_norm_RNase_sums, Rep_3_norm_RNase_sums, Rep_1_norm_Ctrl_sums, Rep_2_norm_Ctrl_sums, Rep_3_norm_Ctrl_sums)
Total_Protein_norm_new = t(Total_Protein_by_fractions_new)/1
Total_Protein_norm_new = as.data.frame(Total_Protein_norm_new)
Total_Protein_norm_new
Total_Protein_amount_norm_new = rowSums(Total_Protein_norm_new)
Total_Protein_amount_norm_new
plotdata_norm_new = data.frame(Total_Protein_amount_norm_new, Replicates = c("RNase1", "RNase2", "RNase3", "Ctrl1", "Ctrl2", "Ctrl3"))
colour1  = c("maroon1", "orchid3", "skyblue", "hotpink", "plum1", "skyblue1")
ggplot(plotdata_norm_new, aes(Replicates, Total_Protein_amount_norm_new )) +
  geom_bar(stat = "identity", fill = colour) +
  labs( title = "After Normalization 1 new", y = "Total protein amout", x = "Replicates")
```

```{r}
Rep_3_norm_RNase_sums
Rep_2_norm_RNase_sums
Rep_1_norm_RNase_sums

Rep_3_norm_Ctrl_sums
Rep_2_norm_Ctrl_sums
Rep_1_norm_Ctrl_sums



```



```{r}
Fractions = c(1:25)

MICA_HUMAN_Protein_Ctrl_Norm_1 = ggplot() + 
  geom_line(data = select(Rep_1_norm_Ctrl, contains("MICA_HUMAN_Rep_1")),  aes(x = Fractions, y = MICA_HUMAN_Rep_1, color= 'Ctrl_Rep1')) + 
  
  geom_line(data = select(Rep_2_norm_Ctrl, contains("MICA_HUMAN_Rep_2")),  aes(x = Fractions, y = MICA_HUMAN_Rep_2 , color= 'Ctrl_Rep2')) + 
  
  geom_line(data = select(Rep_3_norm_Ctrl, contains("MICA_HUMAN_Rep_3")),  aes(x = Fractions, y = MICA_HUMAN_Rep_3 , color= 'Ctrl_Rep3')) +
  
  scale_colour_manual(name="legend",values=c(Ctrl_Rep1="blue2",Ctrl_Rep2="purple4", Ctrl_Rep3="magenta1")) +
  
  labs(title="MICA_HUMAN_Ctrl_Norm_1", y= "Protein Amount") 
 MICA_HUMAN_Protein_Ctrl_Norm_1 + scale_x_continuous(breaks = seq(1, 25, by = 1))
 
#By Madleen    
MICA_HUMAN_Protein_RNase_Norm_1 = ggplot() + 
  geom_line(data = select(Rep_1_norm_RNase, contains("MICA_HUMAN_Rep_1")), lwd=0.2,  aes(x = Fractions, y = MICA_HUMAN_Rep_1, color= 'Ctrl_Rep1')) +
  theme(panel.background = element_rect(fill='white', colour='black'))+
  theme(panel.border = element_blank(), panel.grid.major = element_blank(), panel.grid.minor = element_blank(), axis.line = element_line(size = 0.5, linetype = "solid", colour = "black"))+

  geom_line(data = select(Rep_2_norm_RNase, contains("MICA_HUMAN_Rep_2")), lwd=0.2,  aes(x = Fractions, y = MICA_HUMAN_Rep_2 , color= 'Ctrl_Rep2')) + 
  
  geom_line(data = select(Rep_3_norm_RNase, contains("MICA_HUMAN_Rep_3")), lwd=0.2,   aes(x = Fractions, y = MICA_HUMAN_Rep_3 , color= 'Ctrl_Rep3')) +
  
  scale_colour_manual(name="legend",values=c(Ctrl_Rep1="blue2",Ctrl_Rep2="purple4", Ctrl_Rep3="magenta1")) +
  
  labs(title="MICA_HUMAN_RNase_Norm_1", y= "Protein Amount") 
 MICA_HUMAN_Protein_RNase_Norm_1 + scale_x_continuous(breaks = seq(1, 25, by = 1))
```



```{r Fraction-wise total protein amounts Ctrl, echo=FALSE, fig.width=10, fig.height=7}

#by Madleen --> muss an die neue Normalisierung angwpasst werden!!!

barplot(rowSums(Rep_1_Ctrl_Norm), names.arg = c(1:25), col= "maroon1",space=0.5 ,main= "After Normalization 1 - Rep_1_Ctrl", xlab = "Fractions" , ylab = "Protein Amount",axisnames=T	, las=1)
barplot(rowSums(Rep_2_Ctrl_Norm), names.arg = c(1:25), col= "orchid3",space=0.5 ,main= "After Normalization 1 - Rep_2_Ctrl", xlab = "Fractions" , ylab = "Protein Amount",axisnames=T	, las=1)
barplot(rowSums(Rep_3_Ctrl_Norm),names.arg = c(1:25), col= "skyblue",space=0.5 ,main= "After Normalization 1 - Rep_3_Ctrl", xlab = "Fractions" , ylab = "Protein Amount",axisnames=T	, las=1) 


barplot(rowSums(Rep_1_RNase_Norm),names.arg = c(1:25), col= "lightgreen",space=0.5 ,main= "After Normalization 1 - Rep_1_RNase_Norm", xlab = "Fractions" , ylab = "Protein Amount",axisnames=T	, las=1)
barplot(rowSums(Rep_2_RNase_Norm),names.arg = c(1:25), col= "purple",space=0.5 ,main= "After Normalization 1 - Rep_2_RNase_Norm", xlab = "Fractions" , ylab = "Protein Amount",axisnames=T	, las=1)
barplot(rowSums(Rep_3_RNase_Norm),names.arg = c(1:25), col= "salmon",space=0.5 ,main= "After Normalization 1 - Rep_3_RNase_Norm", xlab = "Fractions" , ylab = "Protein Amount",axisnames=T	, las=1)
```


## 2.2 Second Normalization (by Greta)


```{r by Khalida }
# in order that Gretas function works the normalized Datasets have to reordered

Norm_Ctrl = as.data.frame(t(Norm_Ctrl))
Norm_Ctrl = Norm_Ctrl [order(rownames(Norm_Ctrl)), ]


Norm_RNase = as.data.frame(t(Norm_RNase)) 
Norm_RNase = Norm_RNase [order(rownames(Norm_RNase)), ]
```



```{r}
Norm_Ctrl

saveRDS(Norm_Ctrl, file = "Norm_Ctrl.rds")

saveRDS(Norm_RNase, file = "Norm_RNase.rds")

Data_Norm_RNase <- readRDS("Norm_RNase.rds")

Data_Norm_Ctrl <- readRDS("Norm_Ctrl.rds")

```



```{r}
#aim is to eliminate outliers in our dataset, we try to create our own function

anti_outlier_function<- function(input){
#creating the new df  
new_df_anti_outliers<- as.data.frame(matrix(nrow = (dim(input)[1]/3), ncol = dim(input)[2]))
rownames(new_df_anti_outliers) <- rownames(Data.copy)
colnames(new_df_anti_outliers) <- colnames(Data_Norm_RNase)

r<- 1   #r are the rows
while(r <= dim(input)[1]){  
  for (c in 1:dim(input)[2]){    #c are the columns
     rep1 <- input[r,c]   
     rep2 <- input[r+1,c] 
     rep3 <- input[r+2,c]
     if( (abs(rep1-rep2)<abs(rep1-rep3)) && (abs(rep1-rep2)<abs(rep2-rep3)) ) {
        mean <- mean(c(rep1,rep2))
        }
     else if( (abs(rep1-rep3)<abs(rep1-rep2)) && (abs(rep1-rep3)<abs(rep2-rep3)) ) {
       mean <- mean(c(rep1,rep3))  
            }
     else {
       mean <- mean(c(rep2,rep3))
       }
     new_df_anti_outliers[(r/3)+1,(c)] <- mean   
     }
  r <- r + 3
}

new_df_anti_outliers = new_df_anti_outliers[-dim(new_df_anti_outliers)[1],]

return(new_df_anti_outliers)
}

Ctrl_anti_outlier_df = anti_outlier_function(Data_Norm_Ctrl)
RNase_anti_outlier_df = anti_outlier_function(Data_Norm_RNase)


#dataframe combi of mean and two remaining original replicates
df_combi_function<- function(input){
#creating the new df  
new_df_combi<- as.data.frame(matrix(nrow = (dim(input)[1]), ncol = dim(input)[2])) 
rownames(new_df_combi) <- rownames(Data_Norm_Ctrl)
colnames(new_df_combi) <- colnames(Data_Norm_RNase)

r<- 1   #r are the rows
while(r<=dim(input)[1]) {  
  for (c in 1:dim(input)[2]) {    #c are the columns
     rep1 <- input[r,c]   
     rep2 <- input[r+1,c] 
     rep3 <- input[r+2,c]
     if( (abs(rep1-rep2)<abs(rep1-rep3)) && (abs(rep1-rep2)<abs(rep2-rep3)) ) {
       mean <- mean(c(rep1,rep2))
       new_df_combi[r,(c)] <- mean
       new_df_combi[r+1,(c)] <- rep1
       new_df_combi[r+2,(c)] <- rep2
       }
     else if( (abs(rep1-rep3)<abs(rep1-rep2)) && (abs(rep1-rep3)<abs(rep2-rep3)) ) {
       mean <- mean(c(rep1,rep3)) 
       new_df_combi[r,(c)] <- mean
       new_df_combi[r+1,(c)] <- rep1
       new_df_combi[r+2,(c)] <- rep3
       }
     else {
       mean <- mean(c(rep2,rep3))
       new_df_combi[r,(c)] <- mean
       new_df_combi[r+1,(c)] <- rep2
       new_df_combi[r+2,(c)] <- rep3
       }
     }
  r <- r + 3
  }
#new_df_combi = new_df_combi[-dim(new_df_combi)[1],]
return(new_df_combi)
}

Ctrl_combi_df = df_combi_function(Data_Norm_Ctrl)
RNase_combi_df = df_combi_function(Data_Norm_RNase)
Ctrl_combi_df

tCtrl_combi_df = as.data.frame(t(Ctrl_combi_df))
tRNase_combi_df = as.data.frame(t(RNase_combi_df))

# Changed: rows of last 3 loops and adds # to row 462
```



```{r}
Fractions = c(1:25)

MICA_HUMAN_Protein_Ctrl = ggplot() + 
  geom_line(data = select(Ctrl, contains("MICA_HUMAN_Rep_1")),  aes(x = Fractions, y = MICA_HUMAN_Rep_1, color= 'Ctrl_Rep1')) + 
  
  geom_line(data = select(Ctrl, contains("MICA_HUMAN_Rep_2")),  aes(x = Fractions, y = MICA_HUMAN_Rep_2 , color= 'Ctrl_Rep2')) + 
  
  geom_line(data = select(Ctrl, contains("MICA_HUMAN_Rep_3")),  aes(x = Fractions, y = MICA_HUMAN_Rep_3 , color= 'Ctrl_Rep3')) +
  
  scale_colour_manual(name="legend",values=c(Ctrl_Rep1="blue2",Ctrl_Rep2="purple4", Ctrl_Rep3="magenta1")) +
  
  labs(title="MICA_HUMAN_Ctrl", y= "Protein Amount") 
 MICA_HUMAN_Protein_Ctrl + scale_x_continuous(breaks = seq(1, 25, by = 1))
    
 
MICA_HUMAN_Protein_Ctrl_Norm_Second = ggplot() + 
  geom_line(data = select(tCtrl_combi_df, contains("MICA_HUMAN_Rep_1")),  aes(x = Fractions, y = MICA_HUMAN_Rep_1, color= 'Ctrl_Rep1')) + 
  
  geom_line(data = select(tCtrl_combi_df, contains("MICA_HUMAN_Rep_2")),  aes(x = Fractions, y = MICA_HUMAN_Rep_2 , color= 'Ctrl_Rep2')) + 
  
  geom_line(data = select(tCtrl_combi_df, contains("MICA_HUMAN_Rep_3")),  aes(x = Fractions, y = MICA_HUMAN_Rep_3 , color= 'Ctrl_Rep3')) +
  
  scale_colour_manual(name="legend",values=c(Ctrl_Rep1="blue2",Ctrl_Rep2="purple4", Ctrl_Rep3="magenta1")) +
  
  labs(title="MICA_HUMAN_Ctrl_Norm_Second", y= "Protein Amount") 
 MICA_HUMAN_Protein_Ctrl_Norm_Second + scale_x_continuous(breaks = seq(1, 25, by = 1))
 
 #By Madleen    
MICA_HUMAN_Protein_Ctrl_Norm_Second = ggplot() + 
  geom_line(data = select(tCtrl_combi_df, contains("MICA_HUMAN_Rep_1")), lwd=0.2,  aes(x = Fractions, y = MICA_HUMAN_Rep_1, color= 'Ctrl_Rep1')) +
  theme(panel.background = element_rect(fill='white', colour='black'))+
  theme(panel.border = element_blank(), panel.grid.major = element_blank(), panel.grid.minor = element_blank(), axis.line = element_line(size = 0.5, linetype = "solid", colour = "black"))+

  geom_line(data = select(tCtrl_combi_df, contains("MICA_HUMAN_Rep_2")), lwd=0.2,  aes(x = Fractions, y = MICA_HUMAN_Rep_2 , color= 'Ctrl_Rep2')) + 
  
  geom_line(data = select(tCtrl_combi_df, contains("MICA_HUMAN_Rep_3")), lwd=0.2,   aes(x = Fractions, y = MICA_HUMAN_Rep_3 , color= 'Ctrl_Rep3')) +
  
  scale_colour_manual(name="legend",values=c(Ctrl_Rep1="blue2",Ctrl_Rep2="purple4", Ctrl_Rep3="magenta1")) +
  
  labs(title="MICA_HUMAN_RNase_Norm_second", y= "Protein Amount") 
 MICA_HUMAN_Protein_Ctrl_Norm_Second + scale_x_continuous(breaks = seq(1, 25, by = 1))
```


## 3. Peaks Identification 

We define a threshold

Proteins which depend on RNA are expected to migrate to different positions in the RNase treated sample in comparison to the Ctrl sample. To identify whether a protein is a RBP or not we need to detect the maxima in both samples. We want to detect both local and global maxima because even a shift of a local maximum could hold relevant biological information.
We defined a maximum as a point x whose neighboring values are smaller than it and who exceeds a threshold value of 20% of the global maximum. 

Defining a maximum the way we did successfully results in detecting local peaks. The threshold allows us to only detect maxima with a certain significance. However, a threshold of 20% protein value is not enough to really get only significant maxima. The significance could be further increased by comparing the values of +2  fractions from the maxima or by fitting the curve. 

After we execute the fraction-wise normalization the protein amount between all three Ctrl 
replicates as well as between the three RNase replicates should be equal.
In order to check if this is the case the "bar.total.prot"-function sums all normalized columns for the three Ctrl and RNase replicates and gives out a bar plot with the respective protein amount.

The bar plot shows that the amount of proteins between the three Ctrl replicate are identical. The same applies for the three RNase sample. The protein amounts between Ctrl and RNase differ from each other.

Main motivation is to determine the role of RNA or non coding RNA in the cell, as RNA molecules are much more than a template for protein production
screen RNA --> molecular mechanisms 
screen proteins and protein complexes (with known functions) which are interacting with RNA  --> new funcions RNA
RBPs --> RNA binding Proteins (Cancer, Neurological disorder, muscular atrophies)
IDEA: identify proteins and complexes affected by RNA
The concept of RNA dependence
A protein is definied as RNA dependent if its molecular interactions are dependent on RNA presence 
RNA dependent protein = RNA binding Proteins (RBP) + RBP-binding proteins (if RBP bound to RNA)
protein wide screen based on succrose density gradient 
Control 
proteins envolved in RNA dependent complex --> same fraction migartion
RNAse
RNA dependent protein complex  will dissociate and individual proteins will migrate in different fractions--> different fractions
Analisis of the protein content of fractions by comparing Control and RNAse samples allows identifacation of RNA dependent shifts 
Normalization is needed in order to compare the data in RNase treted and Control samples 

distribution of protein in 25 fractions of both samples, Control and RNase
find global and local maxima for both 


```{r}
# Global and Maxima Detection (need to add threshold in if function)
maximafunction = function(input, threshold){
  output = 0
  for (i in 1:(length(input))){
    # 1st Fraction
    if (i == 1){
      if(input[i] > input[i+1] && input[i] >= threshold*max(input)){
        output[i] = input[i]}
      else{
        output[i] = 0}
    }

    # 2nd-24th Fraction
    if (i > 1 && i < length(input)){
      if(input[i] > input[i+1] && input[i] > input[i-1] && input[i] >= threshold*max(input)){
        output[i] = input[i]}
      else{
        output[i] = 0}
    }

    # 25th Fraction
    if (i == length(input)){
      if(input[i] > input[i-1] && input[i] >= threshold*max(input)){
        output[i] = input[i]
      }
      else{
        output[i] = 0}
    }
  }
  return(output)
}


# A Vector for Fraction's Names
  fractionnames = 0
  for (i in 1:25) {
    fractionnames[i] = paste("Fraction",i,sep="_")
    }

  
# Creating Maxima Data Frames with different Threshold
for (i in seq(0.1,0.9,0.1)){
  temp = paste("maxima_Ctrl",i,sep="_")
  assign(temp, data.frame(apply(tCtrl_combi_df, 2, function(x){maximafunction(x,i)}), row.names = fractionnames))
} # Output: maxima_Ctrl_i (0.1 <= i <= 0.9)
  
for (i in seq(0.1,0.9,0.1)){
  temp = paste("maxima_RNase",i,sep="_")
  assign(temp, data.frame(apply(tRNase_combi_df, 2, function(x){maximafunction(x,i)}), row.names = fractionnames))
} # Output: maxima_RNase_i (0.1 <= i <= 0.9)


# Function to get numbers of maxima
maximanumber = function(input){
  output = 0
  temp = 0
  for (i in 1:length(input)){
    if (input[i] != 0){
      temp[i] = 1}
      else{
        temp[i] = 0}
  }
  output = sum(temp)
  return(output)
}


# Creating Vectors with numbers of Maxima
for (i in seq(0.1,0.9,0.1)){
  temp1 = paste("maxnum_Ctrl",i,sep="_")
  temp2 = get(paste("maxima_Ctrl",i,sep="_"))
  assign(temp1, apply(temp2, 2, maximanumber))
} # Output: maxnum_Ctrl_i (0.1 <= i <= 0.9)

for (i in seq(0.1,0.9,0.1)){
  temp1 = paste("maxnum_RNase",i,sep="_")
  temp2 = get(paste("maxima_RNase",i,sep="_"))
  assign(temp1, apply(temp2, 2, maximanumber))
} # Output: maxnum_RNase_i (0.1 <= i <= 0.9)
```



```{r}
# Function to plot random protein with threshold in x-axis and number of maxima in y-axis (only correctly works with input either maxnum_Ctrl_0.1 or "maxnum_RNase_0.1", nonetheless with any desired rows
# Richard's code with a couple embellishments by Madleen

maxnum_plot_col = function(){
  row = sample(1:length(maxnum_Ctrl_0.1),1)
  output1 = 0
  output1[1] = maxnum_Ctrl_0.1[row]
  for (i in seq(0.2,0.9,0.1)){
    output1[i*10] = get(paste(gsub("_0.*","","maxnum_Ctrl"),i,sep="_"))[row]
  }
  
  output2 = 0
  output2[1] = maxnum_RNase_0.1[row]
  for (i in seq(0.2,0.9,0.1)){
    output2[i*10] = get(paste(gsub("_0.*","","maxnum_RNase"),i,sep="_"))[row]
  }
  
  plot(seq(0.1,0.9,0.1),col = "red",output1, main = names(maxnum_Ctrl_0.1)[row], xlab="Threshold", ylab="Maxima Number", type="l", lwd=5)
  lines(seq(0.1,0.9,0.1),col = "blue",output2, type="l", lwd=5)
  legend("topright", legend = c("Ctrl", "RNase"), col = c("red", "blue"), lwd = c(5,5), cex = 0.75)
  
}

maxnum_plot_col()
```


## 4. T-Test 

T Test shows us if the global maxima of each of the proteins (all repetitions) between Ctrl and RNase group has a significance difference. A significanct difference between the 2 group will be categorized as RNA dependent and it will be our first criteria for RNA dependency.

```{r}
# Function to make data frame where absolute maxima of 3 Reps of a protein are inserted in a column
abmax = function(input){
  output = data.frame()
  i = 1
  j = 0
  while (i < dim(input)[2]){
    rep1 = max(input[,i])
    rep2 = max(input[,i+1])
    rep3 = max(input[,i+2])
    output[1:3,i-j] = c(rep1, rep2, rep3)
    colnames(output)[i-j] = gsub("_Rep_1", "", colnames(input)[i]) 
    i = i + 3
    j = j + 2
  }
  rownames(output) = c("Rep1", "Rep2","Rep3")
  return(output)
}

abmax_Ctrl = abmax(maxima_Ctrl_0.4)
abmax_RNase = abmax(maxima_RNase_0.4)

# T-Test comparing each corresponding Protein Rep of Ctrl and RNase with Bonferroni Correction
ttest = function(input1, input2, alpha){
  output = data.frame()
  for (i in 1:dim(input1)[2]){
    p = t.test(input1[,i], input2[,i], var.equal = FALSE)$p.value
    output[i,1] = p < alpha
  }
  rownames(output) = colnames(input1)
  colnames(output) = "RNA Dependency"
  return(output)
}

test = ttest(abmax_Ctrl, abmax_RNase, 0.05/dim(abmax_Ctrl)[2])
test[which(is.na(test[,1])),1] = FALSE
length(which(test == TRUE))
test
```


## 5. K-Means Clustering

Through K-Means Clustering and comparing our t test results, we define selection criteria (Y Shift and X Shift) for determining RNA dependent Proteins. Y Shift is the difference of protein amount between the global maxima of Ctrl and RNase Group. X Shift is the difference of locations of global maxima (fraction) between the global maxima of Ctrl and RNase Group. If the X and Y Shift has positive values (left and down Shift), we define the protein as RNA dependent. If the X and Y Shift has negative values or close to zero (right and up Shift), we define the protein as RNA independent. These shifts will be our second criteria for RNA dependency.

```{r}
# Y Shift
y_shift = apply(abmax_Ctrl - abmax_RNase, 2, mean)


# X Shift
rowmax_Ctrl = apply(maxima_Ctrl_0.4, 2, which.max)
rowmax_RNase = apply(maxima_RNase_0.4, 2, which.max)

meanrowmax = function(input){
  output = 0
  i = 1
  j = 0
  while (i < length(input)){
    output[i-j] = (input[i]+input[i+1]+input[i+2])/3
    names(output)[i-j] = gsub("_Rep_1", "", names(input)[i])
    i = i + 3
    j = j + 2
  }
  return(output)
}

x_shift = meanrowmax(rowmax_Ctrl) - meanrowmax(rowmax_RNase)



# Combine Y-Shift and X-Shift in a Data Frame
pxy = data.frame(X_Shift = x_shift, Y_Shift = y_shift)


# Elbow Method
wss = sapply(2:8,function(x){ 
  kmeans(pxy, x, 100)$tot.withinss
})
plot(2:8,wss,type='l',xlab="Number of Clusters", ylab="Total within-clusters Sum of Squares")


# Plotting the Clusters
## By Madleen
library(cluster)
library(factoextra)
km = kmeans(pxy, centers = 3, nstart = 100, iter.max = 100)
fviz_cluster(km, data = pxy, geom = c("point"), main = "K Means Clustering with 3 Clusters")+
  theme(panel.background = element_rect(fill='white', colour='black'))+
  scale_colour_manual(values = c("skyblue", "orange", "red")) +
  scale_fill_manual(values = c("white", "white", "white"))+
  scale_shape_manual(values=c(19,15,17))
```



```{r}
# Comparing RNA Dependency from both T Test and K Means
compare = pxy
compare[,3] = test
compare$Cluster = km$cluster

match = integer(dim(compare)[1])
names(match) = row.names(compare)
if(length(which(compare[,4] == 1)) == 63){
  for(x in 1:dim(compare)[1]){
    if(compare[x,3] == TRUE && compare[x,4] == 1){
      match[x] = TRUE
    }
    else if(compare[x,3] == FALSE && compare[x,4] == 2){
      match[x] = TRUE
    }
    else if(compare[x,3] == FALSE && compare[x,4] == 3){
      match[x] = TRUE
    }
    else{
      match[x] = FALSE
    }
  }
}

if(length(which(compare[,4] == 2)) == 63){
  for(x in 1:dim(compare)[1]){
    if(compare[x,3] == FALSE && compare[x,4] == 1){
      match[x] = TRUE
    }
    else if(compare[x,3] == TRUE && compare[x,4] == 2){
      match[x] = TRUE
    }
    else if(compare[x,3] == FALSE && compare[x,4] == 3){
      match[x] = TRUE
    }
    else{
      match[x] = FALSE
    }
  }
}
  
if(length(which(compare[,4] == 3)) == 63){
  for(x in 1:dim(compare)[1]){
    if(compare[x,3] == FALSE && compare[x,4] == 1){
      match[x] = TRUE
    }
    else if(compare[x,3] == FALSE && compare[x,4] == 2){
      match[x] = TRUE
    }
    else if(compare[x,3] == TRUE && compare[x,4] == 3){
      match[x] = TRUE
    }
    else{
      match[x] = FALSE
    }
  }
}
```



```{r}
# Protein that is RNA dependent according to T Test and K Means Clustering (2 Criteria must be fulfilled ). A value 1 in "match" means that the Results from T-Test and K-Means are the same.
row_rnadep_2 = c()
for (i in 1:length(match)){
  if(match[i] == test[i,1]){
    row_rnadep_2 = append(row_rnadep_2, i)
  }
}
length(row_rnadep_2)


# Protein that is RNA dependent according to T Test and K Means Clustering (only 1 of the 2 Criteria must be satisfied). A value 1 in "match" means that the Results from T-Test and K-Means are the same.
rnacluster = 0
if(length(which(compare[,4] == 1)) == 63){
  rnacluster = 1
}
if(length(which(compare[,4] == 2)) == 63){
  rnacluster = 2
}
if(length(which(compare[,4] == 3)) == 63){
  rnacluster = 3
}

row_rnadep_1 = unique(sort(c(which(compare[,4] == rnacluster), which(test == TRUE))))
length(row_rnadep_1)


# Function to get which row/column of Proteins INCLUDING REPS
whichrow = function(input){
  output = c()
  for (i in 1:length(input)){
    output = append(output, (input[i]*3)-2)
    output = append(output, (input[i]*3)-1)
    output = append(output, input[i]*3)
  }
  return(output)
}


# Data Frames for each RNA dependent and independent proteins (Both Conditions Fulfilled)
Ctrl_Dependent_2 = tCtrl_combi_df[,whichrow(row_rnadep_2)]
Ctrl_Independent_2 = tCtrl_combi_df[,-whichrow(row_rnadep_2)]
RNase_Dependent_2 = tRNase_combi_df[,whichrow(row_rnadep_2)]
RNase_Independent_2 = tRNase_combi_df[,-whichrow(row_rnadep_2)]

Ctrl_Dependent_Abmax_2 = abmax_Ctrl[,row_rnadep_2]
Ctrl_Independent_Abmax_2 = abmax_Ctrl[,-row_rnadep_2]
RNase_Dependent_Abmax_2 = abmax_RNase[,row_rnadep_2]
RNase_Independent_Abmax_2 = abmax_RNase[,-row_rnadep_2]

Ctrl_Dependent_Allmax_2 = maxima_Ctrl_0.4[,whichrow(row_rnadep_2)]
Ctrl_Independent_Allmax_2 = maxima_Ctrl_0.4[,-whichrow(row_rnadep_2)]
RNase_Dependent_Allmax_2 = maxima_RNase_0.4[,whichrow(row_rnadep_2)]
RNase_Independent_Allmax_2 = maxima_RNase_0.4[,-whichrow(row_rnadep_2)]


# Data Frames for each RNA dependent and independent proteins (Either Conditions Fulfilled)
Ctrl_Dependent_1 = tCtrl_combi_df[,whichrow(row_rnadep_1)]
Ctrl_Independent_1 = tCtrl_combi_df[,-whichrow(row_rnadep_1)]
RNase_Dependent_1 = tRNase_combi_df[,whichrow(row_rnadep_1)]
RNase_Independent_1 = tRNase_combi_df[,-whichrow(row_rnadep_1)]

Ctrl_Dependent_Abmax_1 = abmax_Ctrl[,row_rnadep_1]
Ctrl_Independent_Abmax_1 = abmax_Ctrl[,-row_rnadep_1]
RNase_Dependent_Abmax_1 = abmax_RNase[,row_rnadep_1]
RNase_Independent_Abmax_1 = abmax_RNase[,-row_rnadep_1]

Ctrl_Dependent_Allmax_1 = maxima_Ctrl_0.4[,whichrow(row_rnadep_1)]
Ctrl_Independent_Allmax_1 = maxima_Ctrl_0.4[,-whichrow(row_rnadep_1)]
RNase_Dependent_Allmax_1 = maxima_RNase_0.4[,whichrow(row_rnadep_1)]
RNase_Independent_Allmax_1 = maxima_RNase_0.4[,-whichrow(row_rnadep_1)]
```



```{r}


Data.RBPResearch <- read.table("~/Desktop/2022-topic-03-team-04/table_RBP_lists.csv")

```




## 6. Linear Regression


```{r}
# P Value
pvalue = function(input1, input2){
output = numeric()
for (i in 1:dim(input1)[2]){
output[i] = t.test(input1[,i], input2[,i], var.equal = FALSE)$p.value
}
names(output) = colnames(input1)
return(output)
}
p_value = pvalue(abmax_Ctrl, abmax_RNase)


```


Ideas for Linear Regression 

--> Predict the RDeep with only one selection criteria and compare the results with the results we get when we apply both selection criterias

--> Perform multiple linear regression with both criterias and predict if data (additional data) belongs to RDeep or not and compare with actual results (additional data known to be RDeep or not)