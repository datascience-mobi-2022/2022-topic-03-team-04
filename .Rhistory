# Elbow Method
wss = sapply(2:8,function(x){
kmeans(pxy, x, 100)$tot.withinss
})
plot(2:8,wss,type='l',xlab="Number of Clusters", ylab="Total within-clusters Sum of Squares")
# Plotting the Clusters
## By Madleen
library(cluster)
library(factoextra)
km = kmeans(pxy, centers = 3, nstart = 100, iter.max = 100)
fviz_cluster(km, data = pxy, geom = c("point"), main = "K Means Clustering with 3 Clusters")+
theme(panel.background = element_rect(fill='white', colour='black'))+
scale_colour_manual(values = c("skyblue", "orange", "red")) +
scale_fill_manual(values = c("white", "white", "white"))+
scale_shape_manual(values=c(19,15,17))
# Comparing RNA Dependency from both T Test and K Means
compare = pxy
compare[,3] = test
compare$Cluster = km$cluster
match = integer(dim(compare)[1])
names(match) = row.names(compare)
# 3 If's are made because the RNA dependent cluster's number is different every time the kmeans function runs. The number of Proteins that is categorized in the RNA dependent cluster are still the same (63).
if(length(which(compare[,4] == 1)) == 63){
for(x in 1:dim(compare)[1]){
if(compare[x,3] == TRUE && compare[x,4] == 1){
match[x] = TRUE
}
else if(compare[x,3] == FALSE && compare[x,4] == 2){
match[x] = TRUE
}
else if(compare[x,3] == FALSE && compare[x,4] == 3){
match[x] = TRUE
}
else{
match[x] = FALSE
}
}
}
if(length(which(compare[,4] == 2)) == 63){
for(x in 1:dim(compare)[1]){
if(compare[x,3] == FALSE && compare[x,4] == 1){
match[x] = TRUE
}
else if(compare[x,3] == TRUE && compare[x,4] == 2){
match[x] = TRUE
}
else if(compare[x,3] == FALSE && compare[x,4] == 3){
match[x] = TRUE
}
else{
match[x] = FALSE
}
}
}
if(length(which(compare[,4] == 3)) == 63){
for(x in 1:dim(compare)[1]){
if(compare[x,3] == FALSE && compare[x,4] == 1){
match[x] = TRUE
}
else if(compare[x,3] == FALSE && compare[x,4] == 2){
match[x] = TRUE
}
else if(compare[x,3] == TRUE && compare[x,4] == 3){
match[x] = TRUE
}
else{
match[x] = FALSE
}
}
}
# Protein that is RNA dependent according to T Test and K Means Clustering (2 Criteria must be fulfilled ). A value 1 in "match" means that the Results from T-Test and K-Means are the same.
row_rnadep_2 = c()
for (i in 1:length(match)){
if(match[i] == test[i,1]){
row_rnadep_2 = append(row_rnadep_2, i)
}
}
length(row_rnadep_2)
# Protein that is RNA dependent according to T Test and K Means Clustering (only 1 of the 2 Criteria must be satisfied). A value 1 in "match" means that the Results from T-Test and K-Means are the same.
rnacluster = 0
if(length(which(compare[,4] == 1)) == 63){
rnacluster = 1
}
if(length(which(compare[,4] == 2)) == 63){
rnacluster = 2
}
if(length(which(compare[,4] == 3)) == 63){
rnacluster = 3
}
row_rnadep_1 = unique(sort(c(which(compare[,4] == rnacluster), which(test == TRUE))))
length(row_rnadep_1)
# Function to get which row/column of Proteins INCLUDING REPS
whichrow = function(input){
output = c()
for (i in 1:length(input)){
output = append(output, (input[i]*3)-2)
output = append(output, (input[i]*3)-1)
output = append(output, input[i]*3)
}
return(output)
}
# Data Frames for each RNA dependent and independent proteins (Both Conditions Fulfilled)
Ctrl_Dependent_2 = tCtrl_combi_df[,whichrow(row_rnadep_2)]
Ctrl_Independent_2 = tCtrl_combi_df[,-whichrow(row_rnadep_2)]
RNase_Dependent_2 = tRNase_combi_df[,whichrow(row_rnadep_2)]
RNase_Independent_2 = tRNase_combi_df[,-whichrow(row_rnadep_2)]
Ctrl_Dependent_Abmax_2 = abmax_Ctrl[,row_rnadep_2]
Ctrl_Independent_Abmax_2 = abmax_Ctrl[,-row_rnadep_2]
RNase_Dependent_Abmax_2 = abmax_RNase[,row_rnadep_2]
RNase_Independent_Abmax_2 = abmax_RNase[,-row_rnadep_2]
Ctrl_Dependent_Allmax_2 = maxima_Ctrl_0.4[,whichrow(row_rnadep_2)]
Ctrl_Independent_Allmax_2 = maxima_Ctrl_0.4[,-whichrow(row_rnadep_2)]
RNase_Dependent_Allmax_2 = maxima_RNase_0.4[,whichrow(row_rnadep_2)]
RNase_Independent_Allmax_2 = maxima_RNase_0.4[,-whichrow(row_rnadep_2)]
# Data Frames for each RNA dependent and independent proteins (Either Conditions Fulfilled)
Ctrl_Dependent_1 = tCtrl_combi_df[,whichrow(row_rnadep_1)]
Ctrl_Independent_1 = tCtrl_combi_df[,-whichrow(row_rnadep_1)]
RNase_Dependent_1 = tRNase_combi_df[,whichrow(row_rnadep_1)]
RNase_Independent_1 = tRNase_combi_df[,-whichrow(row_rnadep_1)]
Ctrl_Dependent_Abmax_1 = abmax_Ctrl[,row_rnadep_1]
Ctrl_Independent_Abmax_1 = abmax_Ctrl[,-row_rnadep_1]
RNase_Dependent_Abmax_1 = abmax_RNase[,row_rnadep_1]
RNase_Independent_Abmax_1 = abmax_RNase[,-row_rnadep_1]
Ctrl_Dependent_Allmax_1 = maxima_Ctrl_0.4[,whichrow(row_rnadep_1)]
Ctrl_Independent_Allmax_1 = maxima_Ctrl_0.4[,-whichrow(row_rnadep_1)]
RNase_Dependent_Allmax_1 = maxima_RNase_0.4[,whichrow(row_rnadep_1)]
RNase_Independent_Allmax_1 = maxima_RNase_0.4[,-whichrow(row_rnadep_1)]
# P Value
pvalue = function(input1, input2){
output = numeric()
for (i in 1:dim(input1)[2]){
output[i] = t.test(input1[,i], input2[,i], var.equal = FALSE)$p.value
}
names(output) = colnames(input1)
return(output)
}
p_value = pvalue(abmax_Ctrl, abmax_RNase)
# Function to get the mean of 3 Reps
mean_rep = function(input){
output = data.frame(matrix(nrow=25, ncol=3680))
colnames(output) = colnames(abmax_Ctrl)
j = 0
i = 1
temp = 0
while (i<=dim(input)[2]){
temp = (input[,i] + input[,i+1] + input[,i+2])/3
output[,i-j] = temp
i = i+3
j = j+2
}
return(output)
}
Ctrl_mean = mean_rep(tRNase_combi_df)
RNase_mean = mean_rep(tCtrl_combi_df)
# Remove proteins that have constant value from Ctrl- and RNase_mean
const_row = which(sapply(1:dim(Ctrl_mean)[2], function(x){length(unique(Ctrl_mean[,x])) == 1})) # Only use from Ctrl because RNase have 1 constant protein and also the same in Ctrl
Ctrl_mean = Ctrl_mean[,-const_row]
RNase_mean = RNase_mean[,-const_row]
# Correlation between Ctrl and RNase Group
cor = c()
for (i in 1:dim(Ctrl_mean)[2]){
cor[i] = cor(Ctrl_mean[,i], RNase_mean[,i])
}
names(cor) = colnames(Ctrl_mean)
# Remove proteins that have constant value from Y-Shift
y_shift_no_const = y_shift[-const_row]
# Linear Regression between correlation (X Axis) and Y-Shift (Y Axis)
df_lm = data.frame(Y_Shift = y_shift_no_const, Correlation = cor)
lm = lm(Y_Shift ~ Correlation, data = df_lm)
summary(lm)
# Plot Linear Regression (The error is the result of logarithmic transformation of negative values and can be ignored. Logarithmic transformation of the values are chosen to better present the results graphically)
ggplot(data = df_lm, aes(x = Correlation, y = Y_Shift)) +
geom_point(color="blue") +
geom_smooth(method="lm", color="red") +
scale_x_continuous(trans = "log10") +
scale_y_continuous(trans = "log10")
# Plot Residuals
hist(lm$residuals, breaks = 20)
qqnorm(lm$residuals)
qqline(lm$residuals)
# Linear Regression first Prerequisite (Correlation between residuals and x values is 0)
cor(df_lm$Correlation, lm$residuals)
# Linear Regression second Prerequisite (Correlation between expected y and x values is 1)
cor(df_lm$Correlation*lm$coefficients[2] + lm$coefficients[1], df_lm$Correlation)
# Protein names and number of times listed as RBP from data bank is taken and put into new data frame
Data.RBPResearch <- read.table("~/Desktop/2022-topic-03-team-04/table_RBP_lists.csv", header=F, sep = ",")
databank = data.frame(matrix(nrow=5004, ncol=2))
i=31
j=1
while (i<dim(Data.RBPResearch)[1]){
databank[((i-(24*j))/7*j),1] = Data.RBPResearch[i,1]
databank[((i-(24*j))/7*j),2] = Data.RBPResearch[i+3,1]
j= j +1
i = i+24
}
temp_name = databank[,1]
databank = as.integer(databank[,2])
names(databank) = temp_name
# Take only proteins that are at least one time identified as RBP from databank
databank_value = databank[-which(databank == 0)]
# Check how many RNA dependent proteins (2 conditions fulfilled) that are identified through our code and from data bank
temporary_2 = colnames(Ctrl_Dependent_Abmax_2)
temporary_2 = append(temporary_2, numeric(length(databank_value - length(temporary_2))))
RDeep_2 = intersect(names(databank_value), temporary_2)
length(RDeep_2)
# Check how many RNA dependent proteins (either condition fulfilled) that are identified through our code and from data bank
temporary_1 = colnames(Ctrl_Dependent_Abmax_1)
temporary_1 = append(temporary_1, numeric(length(databank_value - length(temporary_1))))
RDeep_1 = intersect(names(databank_value), temporary_1)
length(RDeep_1)
# Protein names and number of times listed as RBP from data bank is taken and put into new data frame
Data.RBPResearch <- read.table("~/Desktop/2022-topic-03-team-04/table_RBP_lists.csv", header=F, sep = ",")
databank = data.frame(matrix(nrow=5004, ncol=2))
i=31
j=1
while (i<dim(Data.RBPResearch)[1]){
databank[((i-(24*j))/7*j),1] = Data.RBPResearch[i,1]
databank[((i-(24*j))/7*j),2] = Data.RBPResearch[i+3,1]
j= j +1
i = i+24
}
temp_name = databank[,1]
databank = as.integer(databank[,2])
names(databank) = temp_name
# Take only proteins that are at least one time identified as RBP from databank
databank_value = databank[-which(databank == 0)]
# Check how many RNA dependent proteins (2 conditions fulfilled) that are identified through our code and from data bank
temporary_2 = colnames(Ctrl_Dependent_Abmax_2)
temporary_2 = append(temporary_2, numeric(length(databank_value - length(temporary_2))))
RDeep_2 = intersect(names(databank_value), temporary_2)
length(RDeep_2)
# Check how many RNA dependent proteins (either condition fulfilled) that are identified through our code and from data bank
temporary_1 = colnames(Ctrl_Dependent_Abmax_1)
temporary_1 = append(temporary_1, numeric(length(databank_value - length(temporary_1))))
RDeep_1 = intersect(names(databank_value), temporary_1)
length(RDeep_1)
temporary_none = colnames(Ctrl_Independent_Abmax_2)
temporary_none = append(temporary_none, numeric(length(databank_value -length(temporary_none))))
Not_identified_RDeep = intersect(names(databank_value), temporary_none)
length(Non_identified_RDeep)
temporary_none = colnames(Ctrl_Independent_Abmax_2)
temporary_none = append(temporary_none, numeric(length(databank_value -length(temporary_none))))
Non_identified_RDeep = intersect(names(databank_value), temporary_none)
length(Non_identified_RDeep)
Non_identified_RDeep
which(Ctrl == CSTF2_HUMAN)
Ctrl %>% select(contains("CSTF2_HUMAN))
Ctrl %>% select(contains("CSTF2_HUMAN))
Ctrl %>% select(contains("CSTF2_HUMAN))
lola = Ctrl %>% select(contains("CSTF2_HUMAN))
lola <- Ctrl %>% select(contains("CSTF2_HUMAN))
lola
lola <- Ctrl %>% select(contains("CSTF2_HUMAN))
lola <- t(Ctrl %>% select(contains("CSTF2_HUMAN)))
lola
lola <- t(Ctrl %>% select(contains("CSTF2_HUMAN)))
lola <- Ctrl %>% select(contains("CSTF2_HUMAN))
lola
lola
l_1 <- Ctrl %>% select(contains("CSTF2_HUMAN))
Non_identified_RDeep
Test1 <- Ctrl %>% select(contains("HNRH1_HUMAN"))
Test1 <- Ctrl %>% select(contains("HNRH1_HUMAN"))
Test1
length(Not_identified_RDeep)
# Protein names and number of times listed as RBP from data bank is taken and put into new data frame
Data.RBPResearch <- read.table("~/Desktop/2022-topic-03-team-04/table_RBP_lists.csv", header=F, sep = ",")
databank = data.frame(matrix(nrow=5004, ncol=2))
i=31
j=1
while (i<dim(Data.RBPResearch)[1]){
databank[((i-(24*j))/7*j),1] = Data.RBPResearch[i,1]
databank[((i-(24*j))/7*j),2] = Data.RBPResearch[i+3,1]
j= j +1
i = i+24
}
temp_name = databank[,1]
databank = as.integer(databank[,2])
names(databank) = temp_name
# Take only proteins that are at least one time identified as RBP from databank
databank_value = databank[-which(databank == 0)]
# Check how many RNA dependent proteins (2 conditions fulfilled) that are identified through our code and from data bank
temporary_2 = colnames(Ctrl_Dependent_Abmax_2)
temporary_2 = append(temporary_2, numeric(length(databank_value - length(temporary_2))))
RDeep_2 = intersect(names(databank_value), temporary_2)
length(RDeep_2)
# Check how many RNA dependent proteins (either condition fulfilled) that are identified through our code and from data bank
temporary_1 = colnames(Ctrl_Dependent_Abmax_1)
temporary_1 = append(temporary_1, numeric(length(databank_value - length(temporary_1))))
RDeep_1 = intersect(names(databank_value), temporary_1)
length(RDeep_1)
# P Value
pvalue = function(input1, input2){
output = numeric()
for (i in 1:dim(input1)[2]){
output[i] = t.test(input1[,i], input2[,i], var.equal = FALSE)$p.value
}
names(output) = colnames(input1)
return(output)
}
p_value = pvalue(abmax_Ctrl, abmax_RNase)
# Function to get the mean of 3 Reps
mean_rep = function(input){
output = data.frame(matrix(nrow=25, ncol=3680))
colnames(output) = colnames(abmax_Ctrl)
j = 0
i = 1
temp = 0
while (i<=dim(input)[2]){
temp = (input[,i] + input[,i+1] + input[,i+2])/3
output[,i-j] = temp
i = i+3
j = j+2
}
return(output)
}
Ctrl_mean = mean_rep(tRNase_combi_df)
RNase_mean = mean_rep(tCtrl_combi_df)
# Remove proteins that have constant value from Ctrl- and RNase_mean
const_row = which(sapply(1:dim(Ctrl_mean)[2], function(x){length(unique(Ctrl_mean[,x])) == 1})) # Only use from Ctrl because RNase have 1 constant protein and also the same in Ctrl
Ctrl_mean = Ctrl_mean[,-const_row]
RNase_mean = RNase_mean[,-const_row]
# Correlation between Ctrl and RNase Group
cor = c()
for (i in 1:dim(Ctrl_mean)[2]){
cor[i] = cor(Ctrl_mean[,i], RNase_mean[,i])
}
names(cor) = colnames(Ctrl_mean)
# Remove proteins that have constant value from Y-Shift
y_shift_no_const = y_shift[-const_row]
# Linear Regression between correlation (X Axis) and Y-Shift (Y Axis)
df_lm = data.frame(Y_Shift = y_shift_no_const, Correlation = cor)
lm = lm(Y_Shift ~ Correlation, data = df_lm)
summary(lm)
# Plot Linear Regression (The error is the result of logarithmic transformation of negative values and can be ignored. Logarithmic transformation of the values are chosen to better present the results graphically)
ggplot(data = df_lm, aes(x = Correlation, y = Y_Shift)) +
geom_point(color="blue") +
geom_smooth(method="lm", color="red") +
scale_x_continuous(trans = "log10") +
scale_y_continuous(trans = "log10")
# Plot Residuals
hist(lm$residuals, breaks = 20)
qqnorm(lm$residuals)
qqline(lm$residuals)
# Linear Regression first Prerequisite (Correlation between residuals and x values is 0)
cor(df_lm$Correlation, lm$residuals)
# Linear Regression second Prerequisite (Correlation between expected y and x values is 1)
cor(df_lm$Correlation*lm$coefficients[2] + lm$coefficients[1], df_lm$Correlation)
# Function to get the mean of 3 Reps
mean_rep = function(input){
output = data.frame(matrix(nrow=25, ncol=3680))
colnames(output) = colnames(abmax_Ctrl)
j = 0
i = 1
temp = 0
while (i<=dim(input)[2]){
temp = (input[,i] + input[,i+1] + input[,i+2])/3
output[,i-j] = temp
i = i+3
j = j+2
}
return(output)
}
Ctrl_mean = mean_rep(tRNase_combi_df)
RNase_mean = mean_rep(tCtrl_combi_df)
# Remove proteins that have constant value from Ctrl- and RNase_mean
const_row = which(sapply(1:dim(Ctrl_mean)[2], function(x){length(unique(Ctrl_mean[,x])) == 1})) # Only use from Ctrl because RNase have 1 constant protein and also the same in Ctrl
Ctrl_mean = Ctrl_mean[,-const_row]
RNase_mean = RNase_mean[,-const_row]
# Correlation between Ctrl and RNase Group
cor = c()
for (i in 1:dim(Ctrl_mean)[2]){
cor[i] = cor(Ctrl_mean[,i], RNase_mean[,i])
}
names(cor) = colnames(Ctrl_mean)
# Remove proteins that have constant value from Y-Shift
y_shift_no_const = y_shift[-const_row]
# Linear Regression between correlation (X Axis) and Y-Shift (Y Axis)
df_lm = data.frame(Y_Shift = y_shift_no_const, Correlation = cor)
lm = lm(Y_Shift ~ Correlation, data = df_lm)
summary(lm)
# Plot Linear Regression (The error is the result of logarithmic transformation of negative values and can be ignored. Logarithmic transformation of the values are chosen to better present the results graphically)
ggplot(data = df_lm, aes(x = Correlation, y = Y_Shift)) +
geom_point(color="blue") +
geom_smooth(method="lm", color="red") +
scale_x_continuous(trans = "log10") +
scale_y_continuous(trans = "log10")
# Plot Residuals
hist(lm$residuals, breaks = 20)
qqnorm(lm$residuals)
qqline(lm$residuals)
# Linear Regression first Prerequisite (Correlation between residuals and x values is 0)
cor(df_lm$Correlation, lm$residuals)
# Linear Regression second Prerequisite (Correlation between expected y and x values is 1)
cor(df_lm$Correlation*lm$coefficients[2] + lm$coefficients[1], df_lm$Correlation)
# Y Shift
y_shift = apply(abmax_Ctrl - abmax_RNase, 2, mean)
# X Shift
rowmax_Ctrl = apply(maxima_Ctrl_0.4, 2, which.max)
rowmax_RNase = apply(maxima_RNase_0.4, 2, which.max)
meanrowmax = function(input){
output = 0
i = 1
j = 0
while (i < length(input)){
output[i-j] = (input[i]+input[i+1]+input[i+2])/3
names(output)[i-j] = gsub("_Rep_1", "", names(input)[i])
i = i + 3
j = j + 2
}
return(output)
}
x_shift = meanrowmax(rowmax_Ctrl) - meanrowmax(rowmax_RNase)
# Combine Y-Shift and X-Shift in a Data Frame
pxy = data.frame(X_Shift = x_shift, Y_Shift = y_shift)
# Elbow Method
wss = sapply(2:8,function(x){
kmeans(pxy, x, 100)$tot.withinss
})
plot(2:8,wss,type='l',xlab="Number of Clusters", ylab="Total within-clusters Sum of Squares")
# Plotting the Clusters
## By Madleen
library(cluster)
library(factoextra)
km = kmeans(pxy, centers = 3, nstart = 100, iter.max = 100)
fviz_cluster(km, data = pxy, geom = c("point"), main = "K Means Clustering with 3 Clusters")+
theme(panel.background = element_rect(fill='white', colour='black'))+
scale_colour_manual(values = c("skyblue", "orange", "red")) +
scale_fill_manual(values = c("white", "white", "white"))+
scale_shape_manual(values=c(19,15,17))
# Comparing RNA Dependency from both T Test and K Means
compare = pxy
compare[,3] = test
compare$Cluster = km$cluster
match = integer(dim(compare)[1])
names(match) = row.names(compare)
# 3 If's are made because the RNA dependent cluster's number is different every time the kmeans function runs. The number of Proteins that is categorized in the RNA dependent cluster are still the same (63).
if(length(which(compare[,4] == 1)) == 63){
for(x in 1:dim(compare)[1]){
if(compare[x,3] == TRUE && compare[x,4] == 1){
match[x] = TRUE
}
else if(compare[x,3] == FALSE && compare[x,4] == 2){
match[x] = TRUE
}
else if(compare[x,3] == FALSE && compare[x,4] == 3){
match[x] = TRUE
}
else{
match[x] = FALSE
}
}
}
if(length(which(compare[,4] == 2)) == 63){
for(x in 1:dim(compare)[1]){
if(compare[x,3] == FALSE && compare[x,4] == 1){
match[x] = TRUE
}
else if(compare[x,3] == TRUE && compare[x,4] == 2){
match[x] = TRUE
}
else if(compare[x,3] == FALSE && compare[x,4] == 3){
match[x] = TRUE
}
else{
match[x] = FALSE
}
}
}
if(length(which(compare[,4] == 3)) == 63){
for(x in 1:dim(compare)[1]){
if(compare[x,3] == FALSE && compare[x,4] == 1){
match[x] = TRUE
}
else if(compare[x,3] == FALSE && compare[x,4] == 2){
match[x] = TRUE
}
else if(compare[x,3] == TRUE && compare[x,4] == 3){
match[x] = TRUE
}
else{
match[x] = FALSE
}
}
}
knitr::opts_chunk$set(echo = TRUE)
read.table("~/Desktop/2022-topic-03-team-04/HS_RBPs.RData", header=TRUE, row.names=1, sep = ";")
read.table("~/Desktop/2022-topic-03-team-04/HS_RBPs.RData", header=TRUE, sep = ";")
Data.RBPResearch_recent <-read.table("~/Desktop/2022-topic-03-team-04/HS_RBPs.RData", header=TRUE, sep = ";")
Data.RBPResearch_recent <-read.table("~/Desktop/2022-topic-03-team-04/HS_RBPs.RData", header=TRUE, sep = ";")
Data.RBPResearch_recent
load("/Users/khalida/Desktop/2022-topic-03-team-04/HS_non_RBPs.RData")
load("/Users/khalida/Desktop/2022-topic-03-team-04/HS_RBPs.RData")
View(HS_RBPs)
View(HS_RBPs)
Data.RBPResearch_recent <-read.table("~/Desktop/2022-topic-03-team-04/HS_RBPs.RData")
Data.RBPResearch_recent <-read.table("~/Desktop/2022-topic-03-team-04/HS_RBPs.RData")
Data.RBPResearch_recent
Data.RBPResearch_recent <-load("~/Desktop/2022-topic-03-team-04/HS_RBPs.RData")
Data.RBPResearch_recent
Data.RBPResearch_recent <-view("~/Desktop/2022-topic-03-team-04/HS_RBPs.RData")
Data.RBPResearch_recent <-load("~/Desktop/2022-topic-03-team-04/HS_RBPs.RData")
load("~/Desktop/2022-topic-03-team-04/HS_RBPs.RData")
load("~/Desktop/2022-topic-03-team-04/HS_RBPs.RData")
HS_RBPs
HS_RBPs
View(HS_RBPs)
load("~/Desktop/2022-topic-03-team-04/HS_RBPs.RData")
HS_RBPs
load("~/Desktop/2022-topic-03-team-04/HS_non_RBPs.RData")
load("~/Desktop/2022-topic-03-team-04/HS_RBPs.RData")
load("~/Desktop/2022-topic-03-team-04/HS_non_RBPs.RData")
