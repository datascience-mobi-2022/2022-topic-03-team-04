assign(temp1, temp3)
} # Result: local_maxima_RNase_i
# Function to make data frame where absolute maxima of 3 Reps of a protein are inserted in a column
abmax = function(input){
output = data.frame()
i = 1
j = 0
while (i < dim(input)[2]){
rep1 = max(input[,i])
rep2 = max(input[,i+1])
rep3 = max(input[,i+2])
output[1:3,i-j] = c(rep1, rep2, rep3)
colnames(output)[i-j] = gsub("_Rep_1", "", colnames(input)[i])
i = i + 3
j = j + 2
}
rownames(output) = c("Rep1", "Rep2","Rep3")
return(output)
}
abmax_Ctrl = abmax(maxima_Ctrl_0.4)
abmax_RNase = abmax(maxima_RNase_0.4)
# T-Test comparing each corresponding Protein Rep of Ctrl and RNase with Bonferroni Correction
ttest = function(input1, input2, alpha){
output = data.frame()
for (i in 1:dim(input1)[2]){
p = t.test(input1[,i], input2[,i], var.equal = FALSE)$p.value
output[i,1] = p < alpha
}
rownames(output) = colnames(input1)
colnames(output) = "RNA Dependency"
return(output)
}
test = ttest(abmax_Ctrl, abmax_RNase, 0.05/dim(abmax_Ctrl)[2])
test[which(is.na(test[,1])),1] = FALSE
length(which(test == TRUE))
test
# Y Shift
y_shift = apply(abmax_Ctrl - abmax_RNase, 2, mean)
# X Shift
rowmax_Ctrl = apply(maxima_Ctrl_0.4, 2, which.max)
rowmax_RNase = apply(maxima_RNase_0.4, 2, which.max)
meanrowmax = function(input){
output = 0
i = 1
j = 0
while (i < length(input)){
output[i-j] = (input[i]+input[i+1]+input[i+2])/3
names(output)[i-j] = gsub("_Rep_1", "", names(input)[i])
i = i + 3
j = j + 2
}
return(output)
}
x_shift = meanrowmax(rowmax_Ctrl) - meanrowmax(rowmax_RNase)
# Combine Y-Shift and X-Shift in a Data Frame
pxy = data.frame(X_Shift = x_shift, Y_Shift = y_shift)
# Elbow Method
wss = sapply(2:8,function(x){
kmeans(pxy, x, 100)$tot.withinss
})
plot(2:8,wss,type='l',xlab="Number of Clusters", ylab="Total within-clusters Sum of Squares")
# Plotting the Clusters
## By Madleen
library(cluster)
library(factoextra)
km = kmeans(pxy, centers = 3, nstart = 100, iter.max = 100)
fviz_cluster(km, data = pxy, geom = c("point"), main = "K Means Clustering with 3 Clusters")+
theme(panel.background = element_rect(fill='white', colour='black'))+
scale_colour_manual(values = c("skyblue", "orange", "red")) +
scale_fill_manual(values = c("white", "white", "white"))+
scale_shape_manual(values=c(19,15,17))
# Comparing RNA Dependency from both T Test and K Means
compare = pxy
compare[,3] = test
compare$Cluster = km$cluster
match = integer(dim(compare)[1])
names(match) = row.names(compare)
# 3 If's are made because the RNA dependent cluster's number is different every time the kmeans function runs. The number of Proteins that is categorized in the RNA dependent cluster are still the same (63).
if(length(which(compare[,4] == 1)) == 63){
for(x in 1:dim(compare)[1]){
if(compare[x,3] == TRUE && compare[x,4] == 1){
match[x] = TRUE
}
else if(compare[x,3] == FALSE && compare[x,4] == 2){
match[x] = TRUE
}
else if(compare[x,3] == FALSE && compare[x,4] == 3){
match[x] = TRUE
}
else{
match[x] = FALSE
}
}
}
if(length(which(compare[,4] == 2)) == 63){
for(x in 1:dim(compare)[1]){
if(compare[x,3] == FALSE && compare[x,4] == 1){
match[x] = TRUE
}
else if(compare[x,3] == TRUE && compare[x,4] == 2){
match[x] = TRUE
}
else if(compare[x,3] == FALSE && compare[x,4] == 3){
match[x] = TRUE
}
else{
match[x] = FALSE
}
}
}
if(length(which(compare[,4] == 3)) == 63){
for(x in 1:dim(compare)[1]){
if(compare[x,3] == FALSE && compare[x,4] == 1){
match[x] = TRUE
}
else if(compare[x,3] == FALSE && compare[x,4] == 2){
match[x] = TRUE
}
else if(compare[x,3] == TRUE && compare[x,4] == 3){
match[x] = TRUE
}
else{
match[x] = FALSE
}
}
}
# Protein that is RNA dependent according to T Test and K Means Clustering (2 Criteria must be fulfilled ). A value 1 in "match" means that the Results from T-Test and K-Means are the same.
row_rnadep_2 = c()
for (i in 1:length(match)){
if(match[i] == test[i,1]){
row_rnadep_2 = append(row_rnadep_2, i)
}
}
length(row_rnadep_2)
# Protein that is RNA dependent according to T Test and K Means Clustering (only 1 of the 2 Criteria must be satisfied). A value 1 in "match" means that the Results from T-Test and K-Means are the same.
rnacluster = 0
if(length(which(compare[,4] == 1)) == 63){
rnacluster = 1
}
if(length(which(compare[,4] == 2)) == 63){
rnacluster = 2
}
if(length(which(compare[,4] == 3)) == 63){
rnacluster = 3
}
row_rnadep_1 = unique(sort(c(which(compare[,4] == rnacluster), which(test == TRUE))))
length(row_rnadep_1)
# Function to get which row/column of Proteins INCLUDING REPS
whichrow = function(input){
output = c()
for (i in 1:length(input)){
output = append(output, (input[i]*3)-2)
output = append(output, (input[i]*3)-1)
output = append(output, input[i]*3)
}
return(output)
}
# Data Frames for each RNA dependent and independent proteins (Both Conditions Fulfilled)
Ctrl_Dependent_2 = tCtrl_combi_df[,whichrow(row_rnadep_2)]
Ctrl_Independent_2 = tCtrl_combi_df[,-whichrow(row_rnadep_2)]
RNase_Dependent_2 = tRNase_combi_df[,whichrow(row_rnadep_2)]
RNase_Independent_2 = tRNase_combi_df[,-whichrow(row_rnadep_2)]
Ctrl_Dependent_Abmax_2 = abmax_Ctrl[,row_rnadep_2]
Ctrl_Independent_Abmax_2 = abmax_Ctrl[,-row_rnadep_2]
RNase_Dependent_Abmax_2 = abmax_RNase[,row_rnadep_2]
RNase_Independent_Abmax_2 = abmax_RNase[,-row_rnadep_2]
Ctrl_Dependent_Allmax_2 = maxima_Ctrl_0.4[,whichrow(row_rnadep_2)]
Ctrl_Independent_Allmax_2 = maxima_Ctrl_0.4[,-whichrow(row_rnadep_2)]
RNase_Dependent_Allmax_2 = maxima_RNase_0.4[,whichrow(row_rnadep_2)]
RNase_Independent_Allmax_2 = maxima_RNase_0.4[,-whichrow(row_rnadep_2)]
# Data Frames for each RNA dependent and independent proteins (Either Conditions Fulfilled)
Ctrl_Dependent_1 = tCtrl_combi_df[,whichrow(row_rnadep_1)]
Ctrl_Independent_1 = tCtrl_combi_df[,-whichrow(row_rnadep_1)]
RNase_Dependent_1 = tRNase_combi_df[,whichrow(row_rnadep_1)]
RNase_Independent_1 = tRNase_combi_df[,-whichrow(row_rnadep_1)]
Ctrl_Dependent_Abmax_1 = abmax_Ctrl[,row_rnadep_1]
Ctrl_Independent_Abmax_1 = abmax_Ctrl[,-row_rnadep_1]
RNase_Dependent_Abmax_1 = abmax_RNase[,row_rnadep_1]
RNase_Independent_Abmax_1 = abmax_RNase[,-row_rnadep_1]
Ctrl_Dependent_Allmax_1 = maxima_Ctrl_0.4[,whichrow(row_rnadep_1)]
Ctrl_Independent_Allmax_1 = maxima_Ctrl_0.4[,-whichrow(row_rnadep_1)]
RNase_Dependent_Allmax_1 = maxima_RNase_0.4[,whichrow(row_rnadep_1)]
RNase_Independent_Allmax_1 = maxima_RNase_0.4[,-whichrow(row_rnadep_1)]
# Protein names and number of times listed as RBP from data bank is taken and put into new data frame
Data.RBPResearch <- read.table("~/Desktop/2022-topic-03-team-04/table_RBP_lists.csv", header=F, sep = ",")
databank = data.frame(matrix(nrow=5004, ncol=2))
i=31
j=1
while (i<dim(Data.RBPResearch)[1]){
databank[((i-(24*j))/7*j),1] = Data.RBPResearch[i,1]
databank[((i-(24*j))/7*j),2] = Data.RBPResearch[i+3,1]
j= j +1
i = i+24
}
temp_name = databank[,1]
databank = as.integer(databank[,2])
names(databank) = temp_name
# Take only proteins that are at least one time identified as RBP from databank
databank_value = databank[-which(databank == 0)]
# Check how many RNA dependent proteins (2 conditions fulfilled) that are identified through our code and from data bank
temporary_2 = colnames(Ctrl_Dependent_Abmax_2)
temporary_2 = append(temporary_2, numeric(length(databank_value - length(temporary_2))))
RDeep_2 = intersect(names(databank_value), temporary_2)
length(RDeep_2)
# Check how many RNA dependent proteins (either condition fulfilled) that are identified through our code and from data bank
temporary_1 = colnames(Ctrl_Dependent_Abmax_1)
temporary_1 = append(temporary_1, numeric(length(databank_value - length(temporary_1))))
RDeep_1 = intersect(names(databank_value), temporary_1)
length(RDeep_1)
# Check how many RNA dependent proteins (2 conditions fulfilled) that are identified through our code and from data bank
temporary_2 = colnames(Ctrl_Dependent_Abmax_2)
temporary_2 = append(temporary_2, numeric(length(databank_value - length(temporary_2))))
RDeep_2 = intersect(names(databank_value), temporary_2)
length(RDeep_2)
# Check how many RNA dependent proteins (either condition fulfilled) that are identified through our code and from data bank
temporary_1 = colnames(Ctrl_Dependent_Abmax_1)
temporary_1 = append(temporary_1, numeric(length(databank_value - length(temporary_1))))
RDeep_1 = intersect(names(databank_value), temporary_1)
length(RDeep_1)
# Check how many RNA dependent proteins were not identified
temporary_none = colnames(Ctrl_Independent_Abmax_2)
temporary_none = append(temporary_none, numeric(length(databank_value -length(temporary_none))))
Not_identified_RDeep = intersect(names(databank_value), temporary_none)
length(Not_identified_RDeep)
# T-Test function for local maxima
localtest = function(input1, input2){
i = 1
j = 0
p = c()
output = c()
while(i < length(input1)){
# if NA or only one local maxima exists, it is impossible to do T-Test because there is no standard deviation
if(all(is.na(input1[[i]])) || all(is.na(input2[[i]])) || length(input1[[i]])<2 || length(input2[[i]])<2){
p[i-j] = NA
i = i+3
j = j+2
}
else{
p[i-j] = t.test(input1[[i]], input2[[i]], var.equal = F)$p.value
i = i+3
j = j+2
}
}
# Bonferonni Correction
output = p < 0.05/(length(p)-length(which(is.na(p))))
# Dummy NA for last proteins with no result from t-test. R somehow remove all last NA.
if(length(output) != length(colnames(abmax_Ctrl))){
output = append(output, rep(NA, length(colnames(abmax_Ctrl)) - length(output)))
}
names(output) = colnames(abmax_Ctrl)
output = as.data.frame(output)
return(output)
}
# T Test results from different threshold
for (i in seq(0.1, 0.9, 0.1)){
temp1 = paste("local_maxima_Ctrl",i,sep="_")
temp2 = paste("local_maxima_RNase",i,sep="_")
temp3 = paste("test",i,sep="_")
assign(temp3, localtest(get(temp1), get(temp2)))
} # Result: test_i
# Check which threshold identifies the most RNA dependent proteins
true_num = c()
for (i in seq(0.1, 0.9, 0.1)){
temp = get(paste("test",i,sep="_"))
true_num[i*10] = length(which(temp[,1] != 0))
}
names(true_num) = c(seq(0.1, 0.9, 0.1))
which.max(true_num)
local_maxima_Rdeep = rownames(test_0.4)[which(test_0.4 == TRUE)]
length(local_maxima_Rdeep)
Identified_RDeep_by_local_maxima = intersect(names(databank_value), local_maxima_Rdeep)
length(Identified_RDeep_by_local_maxima)
load("~/Desktop/HS_RBPs.RData")
load("~/Desktop/HS_non_RBPs.RData")
cor(HS_RBPs$Mass_kDa, HS_RBPs$Length_AA)
lm1 = lm(HS_RBPs$Mass_kDa ~ HS_RBPs$Length_AA)
summary(lm1)
ggplot(data = lm1, aes(x = HS_RBPs$Mass_kDa, y = HS_RBPs$Length_AA)) +
geom_point(color="blue") +
geom_smooth(method="lm", color="red") +
scale_x_continuous(trans = "log10") +
scale_y_continuous(trans = "log10")
# Plot Residuals
hist(lm1$residuals, breaks = 20)
qqnorm(lm1$residuals)
qqline(lm1$residuals)
# Function to get the mean of 3 Reps
mean_rep = function(input){
output = data.frame(matrix(nrow=25, ncol=3680))
colnames(output) = colnames(abmax_Ctrl)
j = 0
i = 1
temp = 0
while (i<=dim(input)[2]){
temp = (input[,i] + input[,i+1] + input[,i+2])/3
output[,i-j] = temp
i = i+3
j = j+2
}
return(output)
}
Ctrl_mean = mean_rep(tRNase_combi_df)
RNase_mean = mean_rep(tCtrl_combi_df)
# Remove proteins that have constant value from Ctrl- and RNase_mean
const_row = which(sapply(1:dim(Ctrl_mean)[2], function(x){length(unique(Ctrl_mean[,x])) == 1})) # Only use from Ctrl because RNase have 1 constant protein and also the same in Ctrl
Ctrl_mean = Ctrl_mean[,-const_row]
RNase_mean = RNase_mean[,-const_row]
# Correlation between Ctrl and RNase Group
cor = c()
for (i in 1:dim(Ctrl_mean)[2]){
cor[i] = cor(Ctrl_mean[,i], RNase_mean[,i])
}
names(cor) = colnames(Ctrl_mean)
# Remove proteins that have constant value from Y-Shift
y_shift_no_const = y_shift[-const_row]
# Linear Regression between correlation (X Axis) and Y-Shift (Y Axis)
df_lm = data.frame(Y_Shift = y_shift_no_const, Correlation = cor)
lm = lm(Y_Shift ~ Correlation, data = df_lm)
summary(lm)
# Plot Linear Regression (The error is the result of logarithmic transformation of negative values and can be ignored. Logarithmic transformation of the values are chosen to better present the results graphically)
ggplot(data = df_lm, aes(x = Correlation, y = Y_Shift)) +
geom_point(color="blue") +
geom_smooth(method="lm", color="red") +
scale_x_continuous(trans = "log10") +
scale_y_continuous(trans = "log10")
# Plot Residuals
hist(lm$residuals, breaks = 20)
qqnorm(lm$residuals)
qqline(lm$residuals)
# Linear Regression first Prerequisite (Correlation between residuals and x values is 0)
cor(df_lm$Correlation, lm$residuals)
# Linear Regression second Prerequisite (Correlation between expected y and x values is 1)
cor(df_lm$Correlation*lm$coefficients[2] + lm$coefficients[1], df_lm$Correlation)
#formula = ax^2+bx+c
lm2 = lm(Y_Shift ~ Correlation + I(Correlation^2), data = df_lm)
summary(lm2)
#formula = ax^2+bx+c
lm2 = lm(Y_Shift ~ Correlation + I(Correlation^2), data = df_lm)
summary(lm2)
ggplot(data = lm2, aes(x = Correlation, y = Y_Shift)) +
geom_point(color="blue") +
geom_smooth(method="lm", color="red") +
scale_x_continuous(trans = "log10") +
scale_y_continuous(trans = "log10")
#formula = ax^2+bx+c
lm2 = lm(Y_Shift ~ poly(Correlation, 2 raw = TRUE, data = df_lm)
#formula = ax^2+bx+c
lm2 = lm(Y_Shift ~ poly(Correlation, 2 raw = TRUE), data = df_lm)
#formula = ax^2+bx+c
lm2 = lm(Y_Shift ~ poly(Correlation, 2, raw = TRUE), data = df_lm)
summary(lm2)
ggplot(data = lm2, aes(x = Correlation, y = Y_Shift)) +
geom_point(color="blue") +
geom_smooth(method="lm", color="red") +
scale_x_continuous(trans = "log10") +
scale_y_continuous(trans = "log10")
#formula = ax^2+bx+c
lm2 = lm(Y_Shift ~ poly(Correlation, 2, raw = TRUE), data = df_lm)
summary(lm2)
ggplot(data = lm2, aes(x = Correlation, y = Y_Shift)) +
geom_point(color="blue") +
geom_smooth(method="lm", color="red") +
scale_x_continuous(trans = "log10") +
scale_y_continuous(trans = "log10")
#formula = ax^2+bx+c
lm2 = lm(Y_Shift ~ poly(Correlation, 2, raw = TRUE), data = df_lm)
summary(lm2)
ggplot(data = lm2, aes(x = Correlation, y = Y_Shift)) +
geom_point(color="blue") +
geom_smooth(method="lm", color="red") +
scale_x_continuous() +
scale_y_continuous()
# Function to get the mean of 3 Reps
mean_rep = function(input){
output = data.frame(matrix(nrow=25, ncol=3680))
colnames(output) = colnames(abmax_Ctrl)
j = 0
i = 1
temp = 0
while (i<=dim(input)[2]){
temp = (input[,i] + input[,i+1] + input[,i+2])/3
output[,i-j] = temp
i = i+3
j = j+2
}
return(output)
}
Ctrl_mean = mean_rep(tRNase_combi_df)
RNase_mean = mean_rep(tCtrl_combi_df)
# Remove proteins that have constant value from Ctrl- and RNase_mean
const_row = which(sapply(1:dim(Ctrl_mean)[2], function(x){length(unique(Ctrl_mean[,x])) == 1})) # Only use from Ctrl because RNase have 1 constant protein and also the same in Ctrl
Ctrl_mean = Ctrl_mean[,-const_row]
RNase_mean = RNase_mean[,-const_row]
# Correlation between Ctrl and RNase Group
cor = c()
for (i in 1:dim(Ctrl_mean)[2]){
cor[i] = cor(Ctrl_mean[,i], RNase_mean[,i])
}
names(cor) = colnames(Ctrl_mean)
# Remove proteins that have constant value from Y-Shift
y_shift_no_const = y_shift[-const_row]
# Linear Regression between correlation (X Axis) and Y-Shift (Y Axis)
df_lm = data.frame(Y_Shift = y_shift_no_const, Correlation = cor)
lm = lm(Y_Shift ~ Correlation, data = df_lm)
summary(lm)
# Plot Linear Regression (The error is the result of logarithmic transformation of negative values and can be ignored. Logarithmic transformation of the values are chosen to better present the results graphically)
ggplot(data = df_lm, aes(x = Correlation, y = Y_Shift)) +
geom_point(color="blue") +
geom_smooth(method="lm", color="red") +
scale_x_continuous(trans = "log10") +
scale_y_continuous(trans = "log10")
# Plot Residuals
hist(lm$residuals, breaks = 20)
qqnorm(lm$residuals)
qqline(lm$residuals)
# Linear Regression first Prerequisite (Correlation between residuals and x values is 0)
cor(df_lm$Correlation, lm$residuals)
# Linear Regression second Prerequisite (Correlation between expected y and x values is 1)
cor(df_lm$Correlation*lm$coefficients[2] + lm$coefficients[1], df_lm$Correlation)
#formula = ax^2+bx+c
lm2 = lm(Y_Shift ~ poly(Correlation, 2, raw = TRUE), data = df_lm)
summary(lm2)
#formula = ax^2+bx+c
lm2 = lm(Y_Shift ~ poly(Correlation, 2, raw = TRUE), data = df_lm)
summary(lm2)
ggplot(data = lm2, aes(x = Correlation, y = Y_Shift)) +
geom_point(color="blue") +
geom_smooth(method="lm", color="red") +
scale_x_continuous(trans = "log10") +
scale_y_continuous(trans = "log10")
# y = ax^2 +bx +c
frm = (Y_Shift ~ Correlation) * x^2
lm2 = lm(Y_Shift ~ poly(Correlation, 2, raw = TRUE), data = df_lm)
summary(lm2)
ggplot(data = lm2, aes(x = Correlation, y = Y_Shift)) +
geom_point(color="blue") +
stat_smooth()
# y = ax^2 +bx +c
frm = Y_Shift ~ Correlation * x^2
mdl = nls(formula = frm,data = df_lm )
# y = ax^2 +bx +c
frm = Y_Shift ~ Correlation * x^2
mdl = nls(formula = frm,data = df_lm )
#formula = ax^2+bx+c
lm2 = lm(formula = Y_Shift ~ Correlation + Correlation2, data = df_lm)
#formula = ax^2+bx+c
lm2 = lm(formula = Y_Shift ~ Correlation + Correlation 2, data = df_lm)
#formula = ax^2+bx+c
Correlation2 = Correlation^2
#formula = ax^2+bx+c
Correlation = df_lm$Correlation
Correlation2 = Correlation^2
lm2 = lm(formula = Y_Shift ~ Correlation + Correlation2, data = df_lm)
summary(lm2)
ggplot(data = lm2, aes(x = Correlation, y = Y_Shift)) +
geom_point(color="blue") +
stat_smooth()
# Function to get the mean of 3 Reps
mean_rep = function(input){
output = data.frame(matrix(nrow=25, ncol=3680))
colnames(output) = colnames(abmax_Ctrl)
j = 0
i = 1
temp = 0
while (i<=dim(input)[2]){
temp = (input[,i] + input[,i+1] + input[,i+2])/3
output[,i-j] = temp
i = i+3
j = j+2
}
return(output)
}
Ctrl_mean = mean_rep(tRNase_combi_df)
RNase_mean = mean_rep(tCtrl_combi_df)
# Remove proteins that have constant value from Ctrl- and RNase_mean
const_row = which(sapply(1:dim(Ctrl_mean)[2], function(x){length(unique(Ctrl_mean[,x])) == 1})) # Only use from Ctrl because RNase have 1 constant protein and also the same in Ctrl
Ctrl_mean = Ctrl_mean[,-const_row]
RNase_mean = RNase_mean[,-const_row]
# Correlation between Ctrl and RNase Group
cor = c()
for (i in 1:dim(Ctrl_mean)[2]){
cor[i] = cor(Ctrl_mean[,i], RNase_mean[,i])
}
names(cor) = colnames(Ctrl_mean)
# Remove proteins that have constant value from Y-Shift
y_shift_no_const = y_shift[-const_row]
# Linear Regression between correlation (X Axis) and Y-Shift (Y Axis)
df_lm = data.frame(Y_Shift = y_shift_no_const, Correlation = cor)
lm = lm(Y_Shift ~ Correlation, data = df_lm)
summary(lm)
# Plot Linear Regression (The error is the result of logarithmic transformation of negative values and can be ignored. Logarithmic transformation of the values are chosen to better present the results graphically)
ggplot(data = df_lm, aes(x = Correlation, y = Y_Shift)) +
geom_point(color="blue") +
geom_smooth(method="lm", color="red") +
scale_x_continuous(trans = "log10") +
scale_y_continuous(trans = "log10")
# Plot Residuals
hist(lm$residuals, breaks = 20)
qqnorm(lm$residuals)
qqline(lm$residuals)
# Linear Regression first Prerequisite (Correlation between residuals and x values is 0)
cor(df_lm$Correlation, lm$residuals)
# Linear Regression second Prerequisite (Correlation between expected y and x values is 1)
cor(df_lm$Correlation*lm$coefficients[2] + lm$coefficients[1], df_lm$Correlation)
#formula = ax^2+bx+c
Correlation = df_lm$Correlation
Correlation2 = Correlation^2
lm2 = lm(formula = Y_Shift ~ Correlation + Correlation2, data = df_lm)
summary(lm2)
ggplot(data = lm2, aes(x = Correlation, y = Y_Shift)) +
geom_point(color="blue") +
stat_smooth()
