# Applying the normalization to the data
RNase_Data_norm = data.frame(apply(RNase, 1, norm_func))
Ctrl_Data_norm = data.frame(apply(Ctrl, 1, norm_func))
#Remove the NAs that result from some proteins having 0 Protein amount in certain repetitions.
Ctrl_Data_norm[is.na(Ctrl_Data_norm)] <- 0
Ctrl_Data_norm
tCtrl_Norm <- as.data.frame(t(Ctrl_Data_norm))
tCtrl_Norm
RNase_Data_norm[is.na(RNase_Data_norm)] <- 0
RNase_Data_norm
tRNase_Norm <- as.data.frame(t(RNase_Data_norm))
tRNase_Norm
Total_Protein_sums = as.data.frame(colSums(Total_Protein_by_fractions))
Total_Protein_sums
## New Normalization
Total_Protein_by_fractions_Ctrl =  cbind(Rep_1_Ctrl_fsums, Rep_2_Ctrl_fsums, Rep_3_Ctrl_fsums)
Total_Protein_by_fractions_RNase =   cbind(Rep_1_RNase_fsums, Rep_2_RNase_fsums, Rep_3_RNase_fsums)
Total_Protein_sums_Ctrl = as.data.frame(Total_Protein_sums[1:3,])
Total_Protein_sums_RNase = as.data.frame(Total_Protein_sums[4:6,])
mean_sums = function(x) {
rep1 <- x[1,1]
rep2 <- x[2,1]
rep3 <- x[3,1]
if( (abs(rep1-rep2)<abs(rep1-rep3)) && (abs(rep1-rep2)<abs(rep2-rep3)) ) {
mean_sums <- mean(c(rep1,rep2))
}
else if( (abs(rep1-rep3)<abs(rep1-rep2)) && (abs(rep1-rep3)<abs(rep2-rep3)) ) {
mean_sums <- mean(c(rep1,rep3))
}
else {
mean_sums <- mean(c(rep2,rep3))
}
}
mean_sums_Ctrl = mean_sums(Total_Protein_sums_Ctrl)
mean_sums_RNase = mean_sums(Total_Protein_sums_RNase)
norm_factor_ctrl <- mean_sums_Ctrl / Total_Protein_by_fractions_Ctrl
norm_factor_rnase <- mean_sums_RNase / Total_Protein_by_fractions_RNase
Rep_1_norm_Ctrl = as.data.frame(t(Rep_1_Ctrl_f)) * norm_factor_ctrl[,1]
Rep_1_norm_Ctrl_sums = rowSums(Rep_1_norm_Ctrl)
Rep_2_norm_Ctrl = as.data.frame(t(Rep_2_Ctrl_f)) * norm_factor_ctrl[,2]
Rep_2_norm_Ctrl_sums = rowSums(Rep_2_norm_Ctrl)
Rep_3_norm_Ctrl = as.data.frame(t(Rep_3_Ctrl_f)) * norm_factor_ctrl[,3]
Rep_3_norm_Ctrl_sums = rowSums(Rep_3_norm_Ctrl)
Norm_Ctrl = data.frame(cbind(Rep_1_norm_Ctrl, Rep_2_norm_Ctrl, Rep_3_norm_Ctrl))
Rep_1_norm_RNase = as.data.frame(t(Rep_1_RNase_f)) * norm_factor_rnase[,1]
Rep_1_norm_RNase_sums = rowSums(Rep_1_norm_RNase)
Rep_2_norm_RNase = as.data.frame(t(Rep_2_RNase_f)) * norm_factor_rnase[,2]
Rep_2_norm_RNase_sums = rowSums(Rep_2_norm_RNase)
Rep_3_norm_RNase = as.data.frame(t(Rep_3_RNase_f)) * norm_factor_rnase[,3]
Rep_3_norm_RNase_sums = rowSums(Rep_3_norm_RNase)
Norm_RNase = data.frame(cbind(Rep_1_norm_RNase, Rep_2_norm_RNase, Rep_3_norm_RNase))
Norm_RNase
#Daten zum Ploten New Normalization
Rep_1_norm_RNase_sums = rowSums(Rep_1_norm_RNase)
Rep_2_norm_RNase_sums = rowSums(Rep_2_norm_RNase)
Rep_3_norm_RNase_sums = rowSums(Rep_3_norm_RNase)
Rep_1_norm_Ctrl_sums = rowSums(Rep_1_norm_Ctrl)
Rep_2_norm_Ctrl_sums = rowSums(Rep_2_norm_Ctrl)
Rep_3_norm_Ctrl_sums = rowSums(Rep_3_norm_Ctrl)
#by Madleen
Total_Protein_by_fractions_new = cbind(Rep_1_norm_RNase_sums,Rep_2_norm_RNase_sums, Rep_3_norm_RNase_sums, Rep_1_norm_Ctrl_sums, Rep_2_norm_Ctrl_sums, Rep_3_norm_Ctrl_sums)
Total_Protein_norm_new = t(Total_Protein_by_fractions_new)/1
Total_Protein_norm_new = as.data.frame(Total_Protein_norm_new)
Total_Protein_norm_new
Total_Protein_amount_norm_new = rowSums(Total_Protein_norm_new)
Total_Protein_amount_norm_new
plotdata_norm_new = data.frame(Total_Protein_amount_norm_new, Replicates = c("RNase1", "RNase2", "RNase3", "Ctrl1", "Ctrl2", "Ctrl3"))
colour1  = c("maroon1", "orchid3", "skyblue", "hotpink", "plum1", "skyblue1")
ggplot(plotdata_norm_new, aes(Replicates, Total_Protein_amount_norm_new )) +
geom_bar(stat = "identity", fill = colour) +
labs( title = "After Normalization 1 new", y = "Total protein amout", x = "Replicates")
# in order that Gretas function works the normalized Datasets have to reordered
Norm_Ctrl = as.data.frame(t(Norm_Ctrl))
Norm_Ctrl = Norm_Ctrl [order(rownames(Norm_Ctrl)), ]
Norm_RNase = as.data.frame(t(Norm_RNase))
Norm_RNase = Norm_RNase [order(rownames(Norm_RNase)), ]
Norm_Ctrl
saveRDS(Norm_Ctrl, file = "Norm_Ctrl.rds")
saveRDS(Norm_RNase, file = "Norm_RNase.rds")
Data_Norm_RNase <- readRDS("Norm_RNase.rds")
Data_Norm_Ctrl <- readRDS("Norm_Ctrl.rds")
#aim is to eliminate outliers in our dataset, we try to create our own function
anti_outlier_function<- function(input){
#creating the new df
new_df_anti_outliers<- as.data.frame(matrix(nrow = (dim(input)[1]/3), ncol = dim(input)[2]))
rownames(new_df_anti_outliers) <- rownames(Data.copy)
colnames(new_df_anti_outliers) <- colnames(Data_Norm_RNase)
r<- 1   #r are the rows
while(r <= dim(input)[1]){
for (c in 1:dim(input)[2]){    #c are the columns
rep1 <- input[r,c]
rep2 <- input[r+1,c]
rep3 <- input[r+2,c]
if( (abs(rep1-rep2)<abs(rep1-rep3)) && (abs(rep1-rep2)<abs(rep2-rep3)) ) {
mean <- mean(c(rep1,rep2))
}
else if( (abs(rep1-rep3)<abs(rep1-rep2)) && (abs(rep1-rep3)<abs(rep2-rep3)) ) {
mean <- mean(c(rep1,rep3))
}
else {
mean <- mean(c(rep2,rep3))
}
new_df_anti_outliers[(r/3)+1,(c)] <- mean
}
r <- r + 3
}
new_df_anti_outliers = new_df_anti_outliers[-dim(new_df_anti_outliers)[1],]
return(new_df_anti_outliers)
}
Ctrl_anti_outlier_df = anti_outlier_function(Data_Norm_Ctrl)
RNase_anti_outlier_df = anti_outlier_function(Data_Norm_RNase)
#dataframe combi of mean and two remaining original replicates
df_combi_function<- function(input){
#creating the new df
new_df_combi<- as.data.frame(matrix(nrow = (dim(input)[1]), ncol = dim(input)[2]))
rownames(new_df_combi) <- rownames(Data_Norm_Ctrl)
colnames(new_df_combi) <- colnames(Data_Norm_RNase)
r<- 1   #r are the rows
while(r<=dim(input)[1]) {
for (c in 1:dim(input)[2]) {    #c are the columns
rep1 <- input[r,c]
rep2 <- input[r+1,c]
rep3 <- input[r+2,c]
if( (abs(rep1-rep2)<abs(rep1-rep3)) && (abs(rep1-rep2)<abs(rep2-rep3)) ) {
mean <- mean(c(rep1,rep2))
new_df_combi[r,(c)] <- mean
new_df_combi[r+1,(c)] <- rep1
new_df_combi[r+2,(c)] <- rep2
}
else if( (abs(rep1-rep3)<abs(rep1-rep2)) && (abs(rep1-rep3)<abs(rep2-rep3)) ) {
mean <- mean(c(rep1,rep3))
new_df_combi[r,(c)] <- mean
new_df_combi[r+1,(c)] <- rep1
new_df_combi[r+2,(c)] <- rep3
}
else {
mean <- mean(c(rep2,rep3))
new_df_combi[r,(c)] <- mean
new_df_combi[r+1,(c)] <- rep2
new_df_combi[r+2,(c)] <- rep3
}
}
r <- r + 3
}
#new_df_combi = new_df_combi[-dim(new_df_combi)[1],]
return(new_df_combi)
}
Ctrl_combi_df = df_combi_function(Data_Norm_Ctrl)
RNase_combi_df = df_combi_function(Data_Norm_RNase)
Ctrl_combi_df
tCtrl_combi_df = as.data.frame(t(Ctrl_combi_df))
tRNase_combi_df = as.data.frame(t(RNase_combi_df))
# Changed: rows of last 3 loops and adds # to row 462
Fractions = c(1:25)
MICA_HUMAN_Protein_Ctrl = ggplot() +
geom_line(data = select(Ctrl, contains("MICA_HUMAN_Rep_1")),  aes(x = Fractions, y = MICA_HUMAN_Rep_1, color= 'Ctrl_Rep1')) +
geom_line(data = select(Ctrl, contains("MICA_HUMAN_Rep_2")),  aes(x = Fractions, y = MICA_HUMAN_Rep_2 , color= 'Ctrl_Rep2')) +
geom_line(data = select(Ctrl, contains("MICA_HUMAN_Rep_3")),  aes(x = Fractions, y = MICA_HUMAN_Rep_3 , color= 'Ctrl_Rep3')) +
scale_colour_manual(name="legend",values=c(Ctrl_Rep1="blue2",Ctrl_Rep2="purple4", Ctrl_Rep3="magenta1")) +
labs(title="MICA_HUMAN_Ctrl", y= "Protein Amount")
MICA_HUMAN_Protein_Ctrl + scale_x_continuous(breaks = seq(1, 25, by = 1))
MICA_HUMAN_Protein_Ctrl_Norm_Second = ggplot() +
geom_line(data = select(tCtrl_combi_df, contains("MICA_HUMAN_Rep_1")),  aes(x = Fractions, y = MICA_HUMAN_Rep_1, color= 'Ctrl_Rep1')) +
geom_line(data = select(tCtrl_combi_df, contains("MICA_HUMAN_Rep_2")),  aes(x = Fractions, y = MICA_HUMAN_Rep_2 , color= 'Ctrl_Rep2')) +
geom_line(data = select(tCtrl_combi_df, contains("MICA_HUMAN_Rep_3")),  aes(x = Fractions, y = MICA_HUMAN_Rep_3 , color= 'Ctrl_Rep3')) +
scale_colour_manual(name="legend",values=c(Ctrl_Rep1="blue2",Ctrl_Rep2="purple4", Ctrl_Rep3="magenta1")) +
labs(title="MICA_HUMAN_Ctrl_Norm_Second", y= "Protein Amount")
MICA_HUMAN_Protein_Ctrl_Norm_Second + scale_x_continuous(breaks = seq(1, 25, by = 1))
#By Madleen
MICA_HUMAN_Protein_Ctrl_Norm_Second = ggplot() +
geom_line(data = select(tCtrl_combi_df, contains("MICA_HUMAN_Rep_1")), lwd=0.2,  aes(x = Fractions, y = MICA_HUMAN_Rep_1, color= 'Ctrl_Rep1')) +
theme(panel.background = element_rect(fill='white', colour='black'))+
theme(panel.border = element_blank(), panel.grid.major = element_blank(), panel.grid.minor = element_blank(), axis.line = element_line(size = 0.5, linetype = "solid", colour = "black"))+
geom_line(data = select(tCtrl_combi_df, contains("MICA_HUMAN_Rep_2")), lwd=0.2,  aes(x = Fractions, y = MICA_HUMAN_Rep_2 , color= 'Ctrl_Rep2')) +
geom_line(data = select(tCtrl_combi_df, contains("MICA_HUMAN_Rep_3")), lwd=0.2,   aes(x = Fractions, y = MICA_HUMAN_Rep_3 , color= 'Ctrl_Rep3')) +
scale_colour_manual(name="legend",values=c(Ctrl_Rep1="blue2",Ctrl_Rep2="purple4", Ctrl_Rep3="magenta1")) +
labs(title="MICA_HUMAN_RNase_Norm_second", y= "Protein Amount")
MICA_HUMAN_Protein_Ctrl_Norm_Second + scale_x_continuous(breaks = seq(1, 25, by = 1))
# Global and Maxima Detection (need to add threshold in if function)
maximafunction = function(input, threshold){
output = 0
for (i in 1:(length(input))){
# 1st Fraction
if (i == 1){
if(input[i] > input[i+1] && input[i] >= threshold*max(input)){
output[i] = input[i]}
else{
output[i] = 0}
}
# 2nd-24th Fraction
if (i > 1 && i < length(input)){
if(input[i] > input[i+1] && input[i] > input[i-1] && input[i] >= threshold*max(input)){
output[i] = input[i]}
else{
output[i] = 0}
}
# 25th Fraction
if (i == length(input)){
if(input[i] > input[i-1] && input[i] >= threshold*max(input)){
output[i] = input[i]
}
else{
output[i] = 0}
}
}
return(output)
}
# A Vector for Fraction's Names
fractionnames = 0
for (i in 1:25) {
fractionnames[i] = paste("Fraction",i,sep="_")
}
# Creating Maxima Data Frames with different Threshold
for (i in seq(0.1,0.9,0.1)){
temp = paste("maxima_Ctrl",i,sep="_")
assign(temp, data.frame(apply(tCtrl_combi_df, 2, function(x){maximafunction(x,i)}), row.names = fractionnames))
} # Output: maxima_Ctrl_i (0.1 <= i <= 0.9)
for (i in seq(0.1,0.9,0.1)){
temp = paste("maxima_RNase",i,sep="_")
assign(temp, data.frame(apply(tRNase_combi_df, 2, function(x){maximafunction(x,i)}), row.names = fractionnames))
} # Output: maxima_RNase_i (0.1 <= i <= 0.9)
# Function to get numbers of maxima
maximanumber = function(input){
output = 0
temp = 0
for (i in 1:length(input)){
if (input[i] != 0){
temp[i] = 1}
else{
temp[i] = 0}
}
output = sum(temp)
return(output)
}
# Creating Vectors with numbers of Maxima
for (i in seq(0.1,0.9,0.1)){
temp1 = paste("maxnum_Ctrl",i,sep="_")
temp2 = get(paste("maxima_Ctrl",i,sep="_"))
assign(temp1, apply(temp2, 2, maximanumber))
} # Output: maxnum_Ctrl_i (0.1 <= i <= 0.9)
for (i in seq(0.1,0.9,0.1)){
temp1 = paste("maxnum_RNase",i,sep="_")
temp2 = get(paste("maxima_RNase",i,sep="_"))
assign(temp1, apply(temp2, 2, maximanumber))
} # Output: maxnum_RNase_i (0.1 <= i <= 0.9)
# Function to plot random protein with threshold in x-axis and number of maxima in y-axis (only correctly works with input either maxnum_Ctrl_0.1 or "maxnum_RNase_0.1", nonetheless with any desired rows
# Richard's code with a couple embellishments by Madleen
maxnum_plot_col = function(){
row = sample(1:length(maxnum_Ctrl_0.1),1)
output1 = 0
output1[1] = maxnum_Ctrl_0.1[row]
for (i in seq(0.2,0.9,0.1)){
output1[i*10] = get(paste(gsub("_0.*","","maxnum_Ctrl"),i,sep="_"))[row]
}
output2 = 0
output2[1] = maxnum_RNase_0.1[row]
for (i in seq(0.2,0.9,0.1)){
output2[i*10] = get(paste(gsub("_0.*","","maxnum_RNase"),i,sep="_"))[row]
}
plot(seq(0.1,0.9,0.1),col = "red",output1, main = names(maxnum_Ctrl_0.1)[row], xlab="Threshold", ylab="Maxima Number", type="l", lwd=5)
lines(seq(0.1,0.9,0.1),col = "blue",output2, type="l", lwd=5)
legend("topright", legend = c("Ctrl", "RNase"), col = c("red", "blue"), lwd = c(5,5), cex = 0.75)
}
maxnum_plot_col()
# Function to make data frame where absolute maxima of 3 Reps of a protein are inserted in a column
abmax = function(input){
output = data.frame()
i = 1
j = 0
while (i < dim(input)[2]){
rep1 = max(input[,i])
rep2 = max(input[,i+1])
rep3 = max(input[,i+2])
output[1:3,i-j] = c(rep1, rep2, rep3)
colnames(output)[i-j] = gsub("_Rep_1", "", colnames(input)[i])
i = i + 3
j = j + 2
}
rownames(output) = c("Rep1", "Rep2","Rep3")
return(output)
}
abmax_Ctrl = abmax(maxima_Ctrl_0.4)
abmax_RNase = abmax(maxima_RNase_0.4)
# T-Test comparing each corresponding Protein Rep of Ctrl and RNase with Bonferroni Correction
ttest = function(input1, input2, alpha){
output = data.frame()
for (i in 1:dim(input1)[2]){
p = t.test(input1[,i], input2[,i], var.equal = FALSE)$p.value
output[i,1] = p < alpha
}
rownames(output) = colnames(input1)
colnames(output) = "RNA Dependency"
return(output)
}
test = ttest(abmax_Ctrl, abmax_RNase, 0.05/dim(abmax_Ctrl)[2])
test[which(is.na(test[,1])),1] = FALSE
length(which(test == TRUE))
test
# Y Shift
y_shift = apply(abmax_Ctrl - abmax_RNase, 2, mean)
# X Shift
rowmax_Ctrl = apply(maxima_Ctrl_0.4, 2, which.max)
rowmax_RNase = apply(maxima_RNase_0.4, 2, which.max)
meanrowmax = function(input){
output = 0
i = 1
j = 0
while (i < length(input)){
output[i-j] = (input[i]+input[i+1]+input[i+2])/3
names(output)[i-j] = gsub("_Rep_1", "", names(input)[i])
i = i + 3
j = j + 2
}
return(output)
}
x_shift = meanrowmax(rowmax_Ctrl) - meanrowmax(rowmax_RNase)
# Combine Y-Shift and X-Shift in a Data Frame
pxy = data.frame(X_Shift = x_shift, Y_Shift = y_shift)
# Elbow Method
wss = sapply(2:8,function(x){
kmeans(pxy, x, 100)$tot.withinss
})
plot(2:8,wss,type='l',xlab="Number of Clusters", ylab="Total within-clusters Sum of Squares")
# Plotting the Clusters
## By Madleen
library(cluster)
library(factoextra)
km = kmeans(pxy, centers = 3, nstart = 100, iter.max = 100)
fviz_cluster(km, data = pxy, geom = c("point"), main = "K Means Clustering with 3 Clusters")+
theme(panel.background = element_rect(fill='white', colour='black'))+
scale_colour_manual(values = c("skyblue", "orange", "red")) +
scale_fill_manual(values = c("white", "white", "white"))+
scale_shape_manual(values=c(19,15,17))
# Comparing RNA Dependency from both T Test and K Means
compare = pxy
compare[,3] = test
compare$Cluster = km$cluster
match = integer(dim(compare)[1])
names(match) = row.names(compare)
if(length(which(compare[,4] == 1)) == 63){
for(x in 1:dim(compare)[1]){
if(compare[x,3] == TRUE && compare[x,4] == 1){
match[x] = TRUE
}
else if(compare[x,3] == FALSE && compare[x,4] == 2){
match[x] = TRUE
}
else if(compare[x,3] == FALSE && compare[x,4] == 3){
match[x] = TRUE
}
else{
match[x] = FALSE
}
}
}
if(length(which(compare[,4] == 2)) == 63){
for(x in 1:dim(compare)[1]){
if(compare[x,3] == FALSE && compare[x,4] == 1){
match[x] = TRUE
}
else if(compare[x,3] == TRUE && compare[x,4] == 2){
match[x] = TRUE
}
else if(compare[x,3] == FALSE && compare[x,4] == 3){
match[x] = TRUE
}
else{
match[x] = FALSE
}
}
}
if(length(which(compare[,4] == 3)) == 63){
for(x in 1:dim(compare)[1]){
if(compare[x,3] == FALSE && compare[x,4] == 1){
match[x] = TRUE
}
else if(compare[x,3] == FALSE && compare[x,4] == 2){
match[x] = TRUE
}
else if(compare[x,3] == TRUE && compare[x,4] == 3){
match[x] = TRUE
}
else{
match[x] = FALSE
}
}
}
# Protein that is RNA dependent according to T Test and K Means Clustering (2 Criteria must be fulfilled ). A value 1 in "match" means that the Results from T-Test and K-Means are the same.
row_rnadep_2 = c()
for (i in 1:length(match)){
if(match[i] == test[i,1]){
row_rnadep_2 = append(row_rnadep_2, i)
}
}
length(row_rnadep_2)
# Protein that is RNA dependent according to T Test and K Means Clustering (only 1 of the 2 Criteria must be satisfied). A value 1 in "match" means that the Results from T-Test and K-Means are the same.
rnacluster = 0
if(length(which(compare[,4] == 1)) == 63){
rnacluster = 1
}
if(length(which(compare[,4] == 2)) == 63){
rnacluster = 2
}
if(length(which(compare[,4] == 3)) == 63){
rnacluster = 3
}
row_rnadep_1 = unique(sort(c(which(compare[,4] == rnacluster), which(test == TRUE))))
length(row_rnadep_1)
# Function to get which row/column of Proteins INCLUDING REPS
whichrow = function(input){
output = c()
for (i in 1:length(input)){
output = append(output, (input[i]*3)-2)
output = append(output, (input[i]*3)-1)
output = append(output, input[i]*3)
}
return(output)
}
# Data Frames for each RNA dependent and independent proteins (Both Conditions Fulfilled)
Ctrl_Dependent_2 = tCtrl_combi_df[,whichrow(row_rnadep_2)]
Ctrl_Independent_2 = tCtrl_combi_df[,-whichrow(row_rnadep_2)]
RNase_Dependent_2 = tRNase_combi_df[,whichrow(row_rnadep_2)]
RNase_Independent_2 = tRNase_combi_df[,-whichrow(row_rnadep_2)]
Ctrl_Dependent_Abmax_2 = abmax_Ctrl[,row_rnadep_2]
Ctrl_Independent_Abmax_2 = abmax_Ctrl[,-row_rnadep_2]
RNase_Dependent_Abmax_2 = abmax_RNase[,row_rnadep_2]
RNase_Independent_Abmax_2 = abmax_RNase[,-row_rnadep_2]
Ctrl_Dependent_Allmax_2 = maxima_Ctrl_0.4[,whichrow(row_rnadep_2)]
Ctrl_Independent_Allmax_2 = maxima_Ctrl_0.4[,-whichrow(row_rnadep_2)]
RNase_Dependent_Allmax_2 = maxima_RNase_0.4[,whichrow(row_rnadep_2)]
RNase_Independent_Allmax_2 = maxima_RNase_0.4[,-whichrow(row_rnadep_2)]
# Data Frames for each RNA dependent and independent proteins (Either Conditions Fulfilled)
Ctrl_Dependent_1 = tCtrl_combi_df[,whichrow(row_rnadep_1)]
Ctrl_Independent_1 = tCtrl_combi_df[,-whichrow(row_rnadep_1)]
RNase_Dependent_1 = tRNase_combi_df[,whichrow(row_rnadep_1)]
RNase_Independent_1 = tRNase_combi_df[,-whichrow(row_rnadep_1)]
Ctrl_Dependent_Abmax_1 = abmax_Ctrl[,row_rnadep_1]
Ctrl_Independent_Abmax_1 = abmax_Ctrl[,-row_rnadep_1]
RNase_Dependent_Abmax_1 = abmax_RNase[,row_rnadep_1]
RNase_Independent_Abmax_1 = abmax_RNase[,-row_rnadep_1]
Ctrl_Dependent_Allmax_1 = maxima_Ctrl_0.4[,whichrow(row_rnadep_1)]
Ctrl_Independent_Allmax_1 = maxima_Ctrl_0.4[,-whichrow(row_rnadep_1)]
RNase_Dependent_Allmax_1 = maxima_RNase_0.4[,whichrow(row_rnadep_1)]
RNase_Independent_Allmax_1 = maxima_RNase_0.4[,-whichrow(row_rnadep_1)]
# Edited Version is Data.bank
Data.RBPResearch <- read.csv("C:/Users/Archid Knighton/Documents/GitHub/2022-topic-03-team-04/table_RBP_lists.csv", header=T, quote="")
temp = Data.RBPResearch[-c(1:5),1]
Data.bank = data.frame(V1=integer(24))
rownames(Data.bank) = temp[1:24]
i=1
while (i<length(temp)){
Data.bank[,(i/24)] = temp[(i):(i+23)]
i = i+24
}
cor(Ctrl_Dependent_2$ACLY_HUMAN_Rep_, RNase_Dependent_2$ACLY_HUMAN_Rep_1)  # RDeeP
view(Data.bank)
# Edited Version is Data.bank
Data.RBPResearch <- read.table("C:/Users/Archid Knighton/Documents/GitHub/2022-topic-03-team-04/table_RBP_lists.csv", header=T, quote="")
# Edited Version is Data.bank
Data.RBPResearch <- read.table("C:/Users/Archid Knighton/Documents/GitHub/2022-topic-03-team-04/table_RBP_lists.csv", header=T, quote="", sep = ",")
view(Data.RBPResearch)
# Edited Version is Data.bank
Data.RBPResearch <- read.table("C:/Users/Archid Knighton/Documents/GitHub/2022-topic-03-team-04/table_RBP_lists.csv", header=T, sep = ",")
# Edited Version is Data.bank
view(Data.RBPResearch)
class(Data.RBPResearch)
# Edited Version is Data.bank
Data.RBPResearch <- read.table("C:/Users/Archid Knighton/Documents/GitHub/2022-topic-03-team-04/table_RBP_lists.csv", header=T, sep = ",")
temp = Data.RBPResearch[-c(1:5),1]
Data.bank = data.frame(V1=integer(24))
rownames(Data.bank) = temp[1:24]
i=1
while (i<length(temp)){
Data.bank[,(i/24)] = temp[(i):(i+23)]
i = i+24
}
view(temp)
# Edited Version is Data.bank
Data.RBPResearch <- read.table("C:/Users/Archid Knighton/Documents/GitHub/2022-topic-03-team-04/table_RBP_lists.csv", header=F, sep = ",")
temp = Data.RBPResearch[-c(1:5),1]
Data.bank = data.frame(V1=integer(24))
rownames(Data.bank) = temp[1:24]
i=1
while (i<length(temp)){
Data.bank[,(i/24)] = temp[(i):(i+23)]
i = i+24
}
view(Data.RBPResearch)
view(Data.RBPResearch)
# Edited Version is Data.bank
Data.RBPResearch <- read.table("C:/Users/Archid Knighton/Documents/GitHub/2022-topic-03-team-04/table_RBP_lists.csv", header=F, sep = ",")
temp = Data.RBPResearch[-c(1:6),1]
Data.bank = data.frame(V1=integer(24))
rownames(Data.bank) = temp[1:24]
i=1
while (i<length(temp)){
Data.bank[,(i/24)] = temp[(i):(i+23)]
i = i+24
}
view(temp)
view(Data.bank)
# Edited Version is Data.bank
Data.RBPResearch <- read.table("C:/Users/Archid Knighton/Documents/GitHub/2022-topic-03-team-04/table_RBP_lists.csv", header=F, sep = ",")
temp = Data.RBPResearch[-c(1:6),1]
Data.bank = data.frame(V1=integer(24))
rownames(Data.bank) = temp[1:24]
i=1
while (i<length(temp)){
Data.bank[,(i/24)] = temp[(i):(i+23)]
i = i+24
}
view(Data.bank)
